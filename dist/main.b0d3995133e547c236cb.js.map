{"version":3,"file":"main.b0d3995133e547c236cb.js","mappings":"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","sources":["webpack://poster/webpack/runtime/create fake namespace object","webpack://poster/webpack/runtime/load script","webpack://poster/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://poster/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://poster/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://poster/./node_modules/css-loader/dist/runtime/api.js","webpack://poster/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://poster/./src/styles.css","webpack://poster/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://poster/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://poster/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://poster/webpack/bootstrap","webpack://poster/webpack/runtime/compat get default export","webpack://poster/webpack/runtime/define property getters","webpack://poster/webpack/runtime/ensure chunk","webpack://poster/webpack/runtime/get javascript chunk filename","webpack://poster/webpack/runtime/global","webpack://poster/webpack/runtime/hasOwnProperty shorthand","webpack://poster/webpack/runtime/make namespace object","webpack://poster/webpack/runtime/publicPath","webpack://poster/webpack/runtime/jsonp chunk loading","webpack://poster/webpack/runtime/nonce","webpack://poster/./src/styles.css?44b2","webpack://poster/./node_modules/@kurkle/color/dist/color.esm.js","webpack://poster/./node_modules/chart.js/dist/chunks/helpers.dataset.js","webpack://poster/./node_modules/chart.js/dist/chart.js","webpack://poster/./src/chart/chartData.ts","webpack://poster/./src/chart/rotatedLabelsPlugin/rotatedLabelsRotation.ts","webpack://poster/./src/chart/rotatedLabelsPlugin/rotatedLabelsTextAndStyle.ts","webpack://poster/./src/chart/rotatedLabelsPlugin/rotatedLabelsPlugin.ts","webpack://poster/./src/chart/rotatedLabelsPlugin/rotatedLabelsRenderer.ts","webpack://poster/./src/chart/rotatedLabelsPlugin/rotatedLabelsPosition.ts","webpack://poster/./node_modules/i18next/dist/esm/i18next.js","webpack://poster/./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js","webpack://poster/./node_modules/i18next-http-backend/esm/utils.js","webpack://poster/./node_modules/i18next-http-backend/esm/request.js","webpack://poster/./node_modules/i18next-http-backend/esm/index.js","webpack://poster/./src/chart/translatedLabelsPlugin/translatedLabelsPlugin.ts","webpack://poster/./src/configureI18N.ts","webpack://poster/./src/chart/chart.ts","webpack://poster/./src/index.ts"],"sourcesContent":["var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var inProgress = {};\nvar dataWebpackPrefix = \"poster:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\n  margin: 0;\n  padding: 0;\n  background-color: #808080;\n}\n\n* {\n  box-sizing: border-box;\n  -moz-box-sizing: border-box;\n}\n\n.page {\n  width: 297mm;\n  height: 210mm;\n  padding: 13mm 18mm;\n  margin: 10mm auto;\n  border-radius: 5px;\n  background: white;\n  box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);\n\n  position: relative;\n}\n\n.content {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n\n#myChart {\n  max-width: 90%;\n  max-height: 90%;\n}\n\n@page {\n  size: A4 landscape;\n  margin: 0;\n}\n\n@media print {\n  body {\n    background-color: initial;\n  }\n\n  .page {\n    width: initial;\n    min-height: initial;\n    margin: 0;\n    border-radius: initial;\n    background: initial;\n    box-shadow: initial;\n    page-break-after: always;\n  }\n}\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/styles.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,SAAS;EACT,UAAU;EACV,yBAAyB;AAC3B;;AAEA;EACE,sBAAsB;EACtB,2BAA2B;AAC7B;;AAEA;EACE,YAAY;EACZ,aAAa;EACb,kBAAkB;EAClB,iBAAiB;EACjB,kBAAkB;EAClB,iBAAiB;EACjB,2CAA2C;;EAE3C,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,YAAY;EACZ,WAAW;AACb;;AAEA;EACE,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,kBAAkB;EAClB,SAAS;AACX;;AAEA;EACE;IACE,yBAAyB;EAC3B;;EAEA;IACE,cAAc;IACd,mBAAmB;IACnB,SAAS;IACT,sBAAsB;IACtB,mBAAmB;IACnB,mBAAmB;IACnB,wBAAwB;EAC1B;AACF\",\"sourcesContent\":[\"body {\\n  margin: 0;\\n  padding: 0;\\n  background-color: #808080;\\n}\\n\\n* {\\n  box-sizing: border-box;\\n  -moz-box-sizing: border-box;\\n}\\n\\n.page {\\n  width: 297mm;\\n  height: 210mm;\\n  padding: 13mm 18mm;\\n  margin: 10mm auto;\\n  border-radius: 5px;\\n  background: white;\\n  box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);\\n\\n  position: relative;\\n}\\n\\n.content {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  height: 100%;\\n  width: 100%;\\n}\\n\\n#myChart {\\n  max-width: 90%;\\n  max-height: 90%;\\n}\\n\\n@page {\\n  size: A4 landscape;\\n  margin: 0;\\n}\\n\\n@media print {\\n  body {\\n    background-color: initial;\\n  }\\n\\n  .page {\\n    width: initial;\\n    min-height: initial;\\n    margin: 0;\\n    border-radius: initial;\\n    background: initial;\\n    box-shadow: initial;\\n    page-break-after: always;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;","\"use strict\";\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + \"47ba22dd5d287bc0cee5\" + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkposter\"] = self[\"webpackChunkposter\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","\n      import API from \"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../node_modules/css-loader/dist/cjs.js!./styles.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../node_modules/css-loader/dist/cjs.js!./styles.css\";\n       export default content && content.locals ? content.locals : undefined;\n","/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */ function isNonPrimitive(n) {\n    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);\n}\nfunction isNumber(n) {\n    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === 'undefined') {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale , vScale , _parsed  } = meta;\n        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n        const axis = iScale.axis;\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n        if (minDefined) {\n            start = Math.min(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n            if (spanGaps) {\n                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                start -= Math.max(0, distanceToDefinedLo);\n            }\n            start = _limitValue(start, 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            let end = Math.max(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n            if (spanGaps) {\n                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                end += Math.max(0, distanceToDefinedHi);\n            }\n            count = _limitValue(end, start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale , yScale , _scaleRanges  } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\n\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\n\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\n\nconst formatters = {\n values (value) {\n        return isArray(value) ?  value : '' + value;\n    },\n numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\n var Ticks = {\n    formatters\n};\n\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n bounds: 'ticks',\n        clip: true,\n grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\n function getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\n class Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n set(scope, values) {\n        return set(this, scope, values);\n    }\n get(scope) {\n        return getScope$1(this, scope);\n    }\n describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n        /* falls through */ case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x , y , w , h , radius  } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min , max  } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    ''\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === 'undefined') {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy , _context , _subProxy , _stack  } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== 'undefined' && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== 'undefined') {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale  } = meta;\n    const { key ='r'  } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n\n/**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX , offsetY  } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas , currentDevicePixelRatio  } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x , y , box  } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width , height  } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width , height  } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = round1(chart.height * pixelRatio);\n    const deviceWidth = round1(chart.width * pixelRatio);\n    chart.height = round1(chart.height);\n    chart.width = round1(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener('test', null, options);\n            window.removeEventListener('test', null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\n\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start , end , count , loop , style  }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property , start: startBound , end: endBound  } = bounds;\n    const { between , normalize  } = propertyFn(property);\n    const count = points.length;\n    let { start , end , loop  } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\n function _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property , start: startBound , end: endBound  } = bounds;\n    const count = points.length;\n    const { compare , between , normalize  } = propertyFn(property);\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\n function _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\n function findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\n function solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\n function _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n function splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\n function doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale , yScale  } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, 'left'),\n            right: getSizeForArea(xScale, chartArea, 'right'),\n            top: getSizeForArea(yScale, chartArea, 'top'),\n            bottom: getSizeForArea(yScale, chartArea, 'bottom')\n        };\n    }\n    return chartArea;\n}\nfunction getDatasetClipArea(chart, meta) {\n    const clip = meta._clip;\n    if (clip.disabled) {\n        return false;\n    }\n    const area = getDatasetArea(meta, chart.chartArea);\n    return {\n        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n    };\n}\n\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, getStyle as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, getRtlAdapter as aA, overrideTextDirection as aB, _textX as aC, restoreTextDirection as aD, drawPointLegend as aE, distanceBetweenPoints as aF, noop as aG, _setMinAndMaxByKey as aH, niceNum as aI, almostWhole as aJ, almostEquals as aK, _decimalPlaces as aL, Ticks as aM, log10 as aN, _longestText as aO, _filterBetween as aP, _lookup as aQ, isPatternOrGradient as aR, getHoverColor as aS, clone as aT, _merger as aU, _mergerIf as aV, _deprecated as aW, _splitKey as aX, toFontString as aY, splineCurve as aZ, splineCurveMonotone as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, getDatasetClipArea as ah, _elementsEqual as ai, _isClickEvent as aj, _isBetween as ak, _normalizeAngle as al, _readValueToProps as am, _updateBezierControlPoints as an, _computeSegments as ao, _boundSegments as ap, _steppedInterpolation as aq, _bezierInterpolation as ar, _pointInLine as as, _steppedLineTo as at, _bezierCurveTo as au, drawPoint as av, addRoundedRectPath as aw, toTRBL as ax, toTRBLCorners as ay, _boundSegment as az, isArray as b, fontString as b0, toLineHeight as b1, PITAU as b2, INFINITY as b3, RAD_PER_DEG as b4, QUARTER_PI as b5, TWO_THIRDS_PI as b6, _angleDiff as b7, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };\n//# sourceMappingURL=helpers.dataset.js.map\n","/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, i as isObject, d as defaults, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as defined, s as sign, j as createContext, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as getRelativePosition, A as _rlookupByKey, B as _lookupByKey, C as _isPointInArea, D as getAngleFromPoint, E as toPadding, F as each, G as getMaximumSize, I as _getParentNode, J as readUsedSize, K as supportsEventListenerOptions, L as throttled, M as _isDomSupported, N as _factorize, O as finiteOrDefault, Q as callback, R as _addGrace, S as _limitValue, U as toDegrees, V as _measureText, W as _int16Range, X as _alignPixel, Y as clipArea, Z as renderText, $ as unclipArea, a0 as toFont, a1 as _toLeftRightCenter, a2 as _alignStartEnd, a3 as overrides, a4 as merge, a5 as _capitalize, a6 as descriptors, a7 as isFunction, a8 as _attachContext, a9 as _createResolver, aa as _descriptors, ab as mergeIf, ac as uid, ad as debounce, ae as retinaScale, af as clearCanvas, ag as setsEqual, ah as getDatasetClipArea, ai as _elementsEqual, aj as _isClickEvent, ak as _isBetween, al as _normalizeAngle, am as _readValueToProps, an as _updateBezierControlPoints, ao as _computeSegments, ap as _boundSegments, aq as _steppedInterpolation, ar as _bezierInterpolation, as as _pointInLine, at as _steppedLineTo, au as _bezierCurveTo, av as drawPoint, aw as addRoundedRectPath, ax as toTRBL, ay as toTRBLCorners, az as _boundSegment, aA as getRtlAdapter, aB as overrideTextDirection, aC as _textX, aD as restoreTextDirection, aE as drawPointLegend, aF as distanceBetweenPoints, aG as noop, aH as _setMinAndMaxByKey, aI as niceNum, aJ as almostWhole, aK as almostEquals, aL as _decimalPlaces, aM as Ticks, aN as log10, aO as _longestText, aP as _filterBetween, aQ as _lookup } from './chunks/helpers.dataset.js';\nimport '@kurkle/color';\n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = requestAnimFrame.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n color (from, to, factor) {\n        const c0 = color(from || transparent);\n        const c1 = c0.valid && color(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = resolve([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = resolve([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = effects[cfg.easing] || effects.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = resolve([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = resolve([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\n\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!isObject(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(defaults.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!isObject(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            (isArray(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{\n            });\n        }\n        return animations;\n    }\n _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if (isObject(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale , vScale  } = meta;\n    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart , _cachedMeta: meta  } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale , vScale , index: datasetIndex  } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index , [vAxis]: value  } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return createContext(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return createContext(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n static defaults = {};\n static datasetElementType = null;\n static dataElementType = null;\n constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n         this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            unlistenArrayEvents(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if (isObject(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                unlistenArrayEvents(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                listenArrayEvents(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n parse(start, count) {\n        const { _cachedMeta: meta , _data: data  } = this;\n        const { iScale , _stacked  } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if (isArray(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if (isObject(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if (isNumberFinite(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n getMaxOverflow() {\n        return false;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && defined(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(defaults.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\n\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\n function computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if (defined(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if (isNullOrUndef(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if (isArray(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return sign(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static id = 'bar';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'bar',\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        grouped: true,\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'base',\n                    'width',\n                    'height'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category',\n                offset: true,\n                grid: {\n                    offset: true\n                }\n            },\n            _value_: {\n                type: 'linear',\n                beginAtZero: true\n            }\n        }\n    };\n parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseObjectData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n getMaxOverflow() {\n        return 0;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale , vScale  } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index , _cachedMeta: { vScale  }  } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n _getStacks(last, dataIndex) {\n        const { iScale  } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if (isNullOrUndef(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getAxisCount() {\n        return this._getAxis().length;\n    }\n    getFirstScaleIdForIndexAxis() {\n        const scales = this.chart.scales;\n        const indexScaleId = this.chart.options.indexAxis;\n        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();\n    }\n    _getAxis() {\n        const axis = {};\n        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n        for (const dataset of this.chart.data.datasets){\n            axis[valueOrDefault(this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;\n        }\n        return Object.keys(axis);\n    }\n _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n        let center, size;\n        const axisCount = this._getAxisCount();\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n            const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n            const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\n\nclass BubbleController extends DatasetController {\n    static id = 'bubble';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'borderWidth',\n                    'radius'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\n        return values;\n    }\n}\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < TAU) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(HALF_PI, startY, endY);\n        const minX = calcMin(PI, startX, endX);\n        const minY = calcMin(PI + HALF_PI, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static id = 'doughnut';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'circumference',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius',\n                    'startAngle',\n                    'x',\n                    'y',\n                    'offset',\n                    'borderWidth',\n                    'spacing'\n                ]\n            }\n        },\n        cutout: '50%',\n        rotation: 0,\n        circumference: 360,\n        radius: '100%',\n        spacing: 0,\n        indexAxis: 'r'\n    };\n    static descriptors = {\n        _scriptable: (name)=>name !== 'spacing',\n        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        const { labels: { pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                        if (data.labels.length && data.datasets.length) {\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    fontColor: color,\n                                    hidden: !chart.getDataVisibility(i),\n                                    lineDash: style.borderDash,\n                                    lineDashOffset: style.borderDashOffset,\n                                    lineJoin: style.borderJoinStyle,\n                                    lineWidth: style.borderWidth,\n                                    strokeStyle: style.borderColor,\n                                    textAlign: textAlign,\n                                    pointStyle: pointStyle,\n                                    borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if (isObject(data[start])) {\n                const { key ='value'  } = this._parsing;\n                getter = (i)=>+resolveObjectKey(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n _getRotation() {\n        return toRadians(this.options.rotation - 90);\n    }\n _getCircumference() {\n        return toRadians(this.options.circumference);\n    }\n _getRotationExtents() {\n        let min = TAU;\n        let max = -TAU;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n update(mode) {\n        const chart = this.chart;\n        const { chartArea  } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference , rotation  } = this._getRotationExtents();\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = toDimension(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return TAU * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n _getRingWeight(datasetIndex) {\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\n\nclass LineController extends DatasetController {\n    static id = 'line';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        showLine: true,\n        spanGaps: false\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category'\n            },\n            _value_: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line , data: points = [] , _dataset  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\n\nclass PolarAreaController extends DatasetController {\n    static id = 'polarArea';\n static defaults = {\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'startAngle',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius'\n                ]\n            }\n        },\n        indexAxis: 'r',\n        startAngle: 0\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                beginAtZero: true,\n                grid: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                startAngle: 0\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\n\nclass PieController extends DoughnutController {\n    static id = 'pie';\n static defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: '100%'\n    };\n}\n\nclass RadarController extends DatasetController {\n    static id = 'radar';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        indexAxis: 'r',\n        showLine: true,\n        elements: {\n            line: {\n                fill: 'start'\n            }\n        }\n    };\n static overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: 'radialLinear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\n\nclass ScatterController extends DatasetController {\n    static id = 'scatter';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        showLine: false,\n        fill: false\n    };\n static overrides = {\n        interaction: {\n            mode: 'point'\n        },\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = []  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line , _dataset  } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine  } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPieController: PieController,\nPolarAreaController: PolarAreaController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    options;\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller , data , _sorted  } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n        if (!intersect) {\n            const result = lookupMethod(data, axis, value);\n            if (spanGaps) {\n                const { vScale  } = controller._cachedMeta;\n                const { _parsed  } = metaset;\n                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                result.lo -= Math.max(0, distanceToDefinedLo);\n                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                result.hi += Math.max(0, distanceToDefinedHi);\n            }\n            return result;\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index , data  } = metasets[i];\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\n function getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle , endAngle  } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle  } = getAngleFromPoint(element, {\n            x: position.x,\n            y: position.y\n        });\n        if (_angleBetween(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\n var Interaction = {\n    evaluateInteractionItems,\n    modes: {\n index (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n dataset (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n point (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n nearest (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n x (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n y (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\n\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack , pos , stackWeight  } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\n function setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize  } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos , box  } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!isObject(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x , y  } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if (defined(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if (defined(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = toPadding(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        each(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, toPadding(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        each(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\n\nclass BasePlatform {\n acquireContext(canvas, aspectRatio) {}\n releaseContext(context) {\n        return false;\n    }\n addEventListener(chart, type, listener) {}\n removeEventListener(chart, type, listener) {}\n getDevicePixelRatio() {\n        return 1;\n    }\n getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n isAttached(canvas) {\n        return true;\n    }\n updateConfig(config) {\n    }\n}\n\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\n\nconst EXPANDO_KEY = '$chartjs';\n const EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\n function initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = readUsedSize(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = readUsedSize(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x , y  } = getRelativePosition(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = throttled((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = throttled((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\n class DomPlatform extends BasePlatform {\n acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if (isNullOrUndef(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n getMaximumSize(canvas, width, height, aspectRatio) {\n        return getMaximumSize(canvas, width, height, aspectRatio);\n    }\n isAttached(canvas) {\n        const container = canvas && _getParentNode(canvas);\n        return !!(container && container.isConnected);\n    }\n}\n\nfunction _detectPlatform(canvas) {\n    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\n\nclass Element {\n    static defaults = {};\n    static defaultRoutes = undefined;\n    x;\n    y;\n    active = false;\n    options;\n    $animations;\n    tooltipPosition(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return isNumber(this.x) && isNumber(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\n\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = _factorize(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\n function getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = valueOrDefault(majorStart, 0);\n    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\n function getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\n\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\n function sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\n function getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\n function garbageCollect(caches, length) {\n    each(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\n function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\n function getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = toFont(options.font, fallback);\n    const padding = toPadding(options.padding);\n    const lines = isArray(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return createContext(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return createContext(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n     let ret = _toLeftRightCenter(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top , left , bottom , right , chart  } = scale;\n    const { chartArea , scales  } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = _alignStartEnd(align, left, right);\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n         this.id = cfg.id;\n         this.type = cfg.type;\n         this.options = undefined;\n         this.ctx = cfg.ctx;\n         this.chart = cfg.chart;\n         this.top = undefined;\n         this.bottom = undefined;\n         this.left = undefined;\n         this.right = undefined;\n         this.width = undefined;\n         this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n         this.maxWidth = undefined;\n         this.maxHeight = undefined;\n         this.paddingTop = undefined;\n         this.paddingBottom = undefined;\n         this.paddingLeft = undefined;\n         this.paddingRight = undefined;\n         this.axis = undefined;\n         this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n         this.ticks = [];\n         this._gridLineItems = null;\n         this._labelItems = null;\n         this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n         this._startPixel = undefined;\n         this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n parse(raw, index) {\n        return raw;\n    }\n getUserBounds() {\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: finiteOrDefault(_userMin, _suggestedMin),\n            max: finiteOrDefault(_userMax, _suggestedMax),\n            minDefined: isNumberFinite(_userMin),\n            maxDefined: isNumberFinite(_userMax)\n        };\n    }\n getMinMax(canStack) {\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: finiteOrDefault(min, finiteOrDefault(max, min)),\n            max: finiteOrDefault(max, finiteOrDefault(min, max))\n        };\n    }\n getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n getTicks() {\n        return this.ticks;\n    }\n getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        callback(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n update(maxWidth, maxHeight, margins) {\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = _addGrace(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        callback(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        callback(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        callback(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        callback(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        callback(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = callback(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        callback(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        callback(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        callback(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        callback(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first , last , widest , highest  } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = toRadians(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align , padding  } , position  } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        callback(this.options.afterFit, [\n            this\n        ]);\n    }\n isHorizontal() {\n        const { axis , position  } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n isFullSize() {\n        return this.options.fullSize;\n    }\n _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if (isNullOrUndef(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx , _longestTextCache: caches  } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!isNullOrUndef(label) && !isArray(label)) {\n                width = _measureText(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if (isArray(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel =  label[j];\n                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n getLabelForValue(value) {\n        return value;\n    }\n getPixelForValue(value, index) {\n        return NaN;\n    }\n getValueForPixel(pixel) {}\n getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n    }\n getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n getBaseValue() {\n        const { min , max  } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = toRadians(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid , position , border  } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return _alignPixel(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position , ticks: optionTicks  } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align , crossAlign , padding , mirror  } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -toRadians(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = isArray(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = toPadding(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                    case 'inner':\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position , ticks  } = this.options;\n        const rotation = -toRadians(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n drawBackground() {\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n drawBorder() {\n        const { chart , ctx , options: { border , grid  }  } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            clipArea(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            unclipArea(ctx);\n        }\n    }\n drawTitle() {\n        const { ctx , options: { position , title , reverse  }  } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = toFont(title.font);\n        const padding = toPadding(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || isObject(position)) {\n            offset += padding.bottom;\n            if (isArray(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\n        renderText(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n        const bz = valueOrDefault(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return toFont(opts.font);\n    }\n _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\n\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            defaults.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n get(id) {\n        return this.items[id];\n    }\n unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in defaults[scope]) {\n            delete defaults[scope][id];\n            if (this.override) {\n                delete overrides[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = merge(Object.create(null), [\n        parentScope ? defaults.get(parentScope) : {},\n        defaults.get(scope),\n        item.defaults\n    ]);\n    defaults.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        defaults.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                each(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n _exec(method, registry, component) {\n        const camelMethod = _capitalize(method);\n        callback(component['before' + camelMethod], [], component);\n        registry[method](component);\n        callback(component['after' + camelMethod], [], component);\n    }\n _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\n\nclass PluginService {\n    constructor(){\n        this._init = undefined;\n    }\n notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        if (this._init === undefined) {\n            return;\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n            this._init = undefined;\n        }\n        return result;\n    }\n _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if (callback(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!isNullOrUndef(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = valueOrDefault(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\n function allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\n\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = defaults.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction idMatchesAxis(id) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + 'AxisID'] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = overrides[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!isObject(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = mergeIf(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = overrides[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            mergeIf(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        mergeIf(scale, [\n            defaults.scales[scale.type],\n            defaults.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = valueOrDefault(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = resolveObjectKey(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options , type  } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, defaults, key));\n            keys.forEach((key)=>addIfFound(scopes, descriptors, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n chartOptionScopes() {\n        const { options , type  } = this;\n        return [\n            options,\n            overrides[type] || {},\n            defaults.datasets[type] || {},\n            {\n                type\n            },\n            defaults,\n            descriptors\n        ];\n    }\n resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = isFunction(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = _attachContext(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\n        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = _createResolver(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable , isIndexable  } = _descriptors(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar version = \"4.5.1\";\n\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    callback(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    callback(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\n function getCanvas(item) {\n    if (_isDomSupported() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    static defaults = defaults;\n    static instances = instances;\n    static overrides = overrides;\n    static registry = registry;\n    static version = version;\n    static getChart = getChart;\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = uid();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n         this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\n        if (!isNullOrUndef(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            retinaScale(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        clearCanvas(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!retinaScale(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        callback(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        each(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        each(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        each(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        each(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n _removeUnreferencedMetasets() {\n        const { _metasets: metasets , data: { datasets  }  } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType , dataElementType  } = defaults.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n _resetElements() {\n        each(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller  } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            each(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active , _lastEvent  } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n _updateScales() {\n        each(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n _updateHiddenIndices() {\n        const { _hiddenIndices  } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method , start , count  } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!setsEqual(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        each(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, isFunction(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width , height  } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n _drawDataset(meta) {\n        const ctx = this.ctx;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        const clip = getDatasetClipArea(this, meta);\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (clip) {\n            clipArea(ctx, clip);\n        }\n        meta.controller.draw();\n        if (clip) {\n            unclipArea(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n isPointInArea(point) {\n        return _isPointInArea(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = createContext(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if (defined(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas , ctx  } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            clearCanvas(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        each(this.options.events, (type)=>_add(type, listener));\n    }\n bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n unbindEvents() {\n        each(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        each(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [] , options  } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = _isClickEvent(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            callback(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                callback(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return each(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\n\nfunction clipSelf(ctx, element, endAngle) {\n    const { startAngle , x , y , outerRadius , innerRadius , options  } = element;\n    const { borderWidth , borderJoinStyle  } = options;\n    const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n    if (innerRadius > 0) {\n        const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));\n        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n    } else {\n        const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));\n        if (borderJoinStyle === 'round') {\n            ctx.arc(x, y, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);\n        } else if (borderJoinStyle === 'bevel') {\n            const r = 2 * clipWidth * clipWidth;\n            const endX = -r * Math.cos(endAngle + PI / 2) + x;\n            const endY = -r * Math.sin(endAngle + PI / 2) + y;\n            const startX = r * Math.cos(startAngle + PI / 2) + x;\n            const startY = r * Math.sin(startAngle + PI / 2) + y;\n            ctx.lineTo(endX, endY);\n            ctx.lineTo(startX, startY);\n        }\n    }\n    ctx.closePath();\n    ctx.moveTo(0, 0);\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clip('evenodd');\n}\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return _readValueToProps(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, ) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference  } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference , options  } = element;\n    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset , borderRadius  } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== 'miter') {\n        clipSelf(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static id = 'arc';\n    static defaults = {\n        borderAlign: 'center',\n        borderColor: '#fff',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: undefined,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: undefined,\n        circular: true,\n        selfJoin: false\n    };\n    static defaultRoutes = {\n        backgroundColor: 'backgroundColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash'\n    };\n    circumference;\n    endAngle;\n    fullCircles;\n    innerRadius;\n    outerRadius;\n    pixelMargin;\n    startAngle;\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle , distance  } = getAngleFromPoint(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n        const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= TAU || nonZeroBetween;\n        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius'\n        ], useFinalPosition);\n        const { offset , spacing  } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options , circumference  } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\n\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\n function getLineMethod(options) {\n    if (options.stepped) {\n        return _steppedLineTo;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierCurveTo;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\n    const { start: segmentStart , end: segmentEnd  } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\n function pathSegment(ctx, line, segment, params) {\n    const { points , options  } = line;\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move =true , reverse  } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\n function fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count , start , ilen  } = pathVars(points, segment, params);\n    const { move =true , reverse  } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\n function _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\n function _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _steppedInterpolation;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierInterpolation;\n    }\n    return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments , options  } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static id = 'line';\n static defaults = {\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: 'miter',\n        borderWidth: 3,\n        capBezierPoints: true,\n        cubicInterpolationMode: 'default',\n        fill: false,\n        spanGaps: false,\n        stepped: false,\n        tension: 0\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n    };\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n    }\n first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = _boundSegments(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start , end  } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value  } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static id = 'point';\n    parsed;\n    skip;\n    stop;\n    /**\n   * @type {any}\n   */ static defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: 'circle',\n        radius: 3,\n        rotation: 0\n    };\n    /**\n   * @type {any}\n   */ static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        drawPoint(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\n\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x , y , base , width , height  } =  bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = toTRBL(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius  } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = toTRBLCorners(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || isObject(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n function addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static id = 'bar';\n static defaults = {\n        borderSkipped: 'start',\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: 'auto',\n        pointStyle: undefined\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\n        const { inner , outer  } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , base , horizontal  } =  this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nBarElement: BarElement,\nLineElement: LineElement,\nPointElement: PointElement\n});\n\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets  } , options: chartOptions  } = chart.config;\n        const { elements  } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx , y: pointAy  } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale  } = meta;\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n    if (minDefined) {\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data , indexAxis  } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if (resolve([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if (isNullOrUndef(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\n\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start , end  } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = _boundSegments(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = _boundSegment(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = _normalizeAngle(start);\n        end = _normalizeAngle(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x =null , y =null  } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start , end  })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if (isArray(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!isNumberFinite(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\n function _decodeFill(line, index, count) {\n     const fill = parseFillOption(line);\n    if (isObject(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if (isNumberFinite(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\n function _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if (isObject(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\n function _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if (isObject(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\n function parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\n\nfunction _buildStackLine(source) {\n    const { scale , index , line  } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\n function getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\n function addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\n function findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if (_isBetween(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\n\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x , y , radius  } = this;\n        bounds = bounds || {\n            start: 0,\n            end: TAU\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x , y , radius  } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\n\nfunction _getTarget(source) {\n    const { chart , fill , line  } = source;\n    if (isNumberFinite(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\n function getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale ={} , fill  } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if (isNumberFinite(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale , fill  } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { chart , index , line , scale , axis  } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above =color , below =color  } = fillOption || {};\n    const meta = chart.getDatasetMeta(index);\n    const clip = getDatasetClipArea(chart, meta);\n    if (target && line.points.length) {\n        clipArea(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis,\n            clip\n        });\n        unclipArea(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line , target , above , below , area , scale , clip  } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    let fillColor = below;\n    if (below !== above) {\n        if (property === 'x') {\n            clipVertical(ctx, target, area.top);\n            fill(ctx, {\n                line,\n                target,\n                color: above,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipVertical(ctx, target, area.bottom);\n        } else if (property === 'y') {\n            clipHorizontal(ctx, target, area.left);\n            fill(ctx, {\n                line,\n                target,\n                color: below,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipHorizontal(ctx, target, area.right);\n            fillColor = above;\n        }\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: fillColor,\n        scale,\n        property,\n        clip\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction clipHorizontal(ctx, target, clipX) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(clipX, firstPoint.y);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(clipX, lastPoint.y);\n        }\n    }\n    ctx.lineTo(clipX, target.first().y);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line , target , property , color , scale , clip  } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src , target: tgt , start , end  } of segments){\n        const { style: { backgroundColor =color  } = {}  } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, clip, bounds) {\n    const chartArea = scale.chart.chartArea;\n    const { property , start , end  } = bounds || {};\n    if (property === 'x' || property === 'y') {\n        let left, top, right, bottom;\n        if (property === 'x') {\n            left = start;\n            top = chartArea.top;\n            right = end;\n            bottom = chartArea.bottom;\n        } else {\n            left = chartArea.left;\n            top = start;\n            right = chartArea.right;\n            bottom = end;\n        }\n        ctx.beginPath();\n        if (clip) {\n            left = Math.max(left, clip.left);\n            right = Math.min(right, clip.right);\n            top = Math.max(top, clip.top);\n            bottom = Math.min(bottom, clip.bottom);\n        }\n        ctx.rect(left, top, right - left, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\n\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\n\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = callback(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options , ctx  } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = toFont(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\n        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            clipArea(ctx, this);\n            this._draw();\n            unclipArea(ctx);\n        }\n    }\n _draw() {\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\n        const { align , labels: labelOpts  } = opts;\n        const defaultColor = defaults.color;\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const labelFont = toFont(labelOpts.font);\n        const { padding  } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = toTRBLCorners(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    addRoundedRectPath(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        overrideTextDirection(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        restoreTextDirection(this.ctx, opts.textDirection);\n    }\n drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = _alignStartEnd(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        renderText(ctx, titleOpts.text, x, y, titleFont);\n    }\n _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                callback(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                callback(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            callback(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = toPadding(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\n\nclass Title extends Element {\n constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\n        this._padding = toPadding(opts.padding);\n        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top , left , bottom , right , options  } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = _alignStartEnd(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = _alignStartEnd(align, bottom, top);\n                rotation = PI * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = _alignStartEnd(align, top, bottom);\n                rotation = PI * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = toFont(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: _toLeftRightCenter(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst positioners = {\n average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = distanceBetweenPoints(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if (isArray(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\n function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\n function createTooltipItem(chart, item) {\n    const { element , datasetIndex , index  } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label , value  } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\n function getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body , footer , title  } = tooltip;\n    const { boxWidth , boxHeight  } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const titleFont = toFont(options.titleFont);\n    const footerFont = toFont(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = toPadding(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    each(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    each(body, (bodyItem)=>{\n        each(bodyItem.before, maxLineWidth);\n        each(bodyItem.lines, maxLineWidth);\n        each(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    each(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y , height  } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x , width  } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x , width  } = size;\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\n function determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x , width  } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y , height  } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\n function getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize , caretPadding , cornerRadius  } = options;\n    const { xAlign , yAlign  } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: _limitValue(x, 0, chart.width - size.width),\n        y: _limitValue(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = toPadding(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return createContext(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: noop,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: noop,\n    beforeBody: noop,\n    beforeLabel: noop,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: noop,\n    afterBody: noop,\n    beforeFooter: noop,\n    footer: noop,\n    afterFooter: noop\n};\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n static positioners = positioners;\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks  } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks  } = options;\n        const bodyItems = [];\n        each(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks  } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        each(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign , yAlign  } = this;\n        const { caretSize , cornerRadius  } = options;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n        const { x: ptX , y: ptY  } = tooltipPoint;\n        const { width , height  } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = toFont(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight , boxWidth  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = toTRBLCorners(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                addRoundedRectPath(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                addRoundedRectPath(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body  } = this;\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        each(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            each(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            each(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        each(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = toFont(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign , yAlign  } = this;\n        const { x , y  } = pt;\n        const { width , height  } = tooltipSize;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = toPadding(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            overrideTextDirection(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            restoreTextDirection(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n _positionChanged(active, e) {\n        const { caretX , caretY , options  } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColors: plugin_colors,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static id = 'category';\n static defaults = {\n        ticks: {\n            callback: _getLabelForValue\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index , label  } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\n\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin , max: rmax  } = dataRange;\n    const minDefined = !isNullOrUndef(min);\n    const maxDefined = !isNullOrUndef(max);\n    const countDefined = !isNullOrUndef(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!isNullOrUndef(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\n    const rad = toRadians(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n         this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero  } = this.options;\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = sign(min);\n            const maxSign = sign(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit , stepSize  } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\n\nclass LinearScale extends LinearScaleBase {\n    static id = 'linear';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.numeric\n        }\n    };\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? min : 0;\n        this.max = isNumberFinite(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = toRadians(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\n\nconst log10Floor = (v)=>Math.floor(log10(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\n function generateTicks(generationOptions, { min , max  }) {\n    min = finiteOrDefault(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = finiteOrDefault(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static id = 'logarithmic';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.logarithmic,\n            major: {\n                enabled: true\n            }\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return isNumberFinite(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n        this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n getLabelForValue(value) {\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = log10(start);\n        this._valueRange = log10(this.max) - log10(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\n\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = toPadding(tickOpts.backdropPadding);\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = isArray(label) ? label : [\n        label\n    ];\n    return {\n        w: _longestText(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\n function fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = toFont(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round(toDegrees(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra , additionalAngle , padding , size  } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left , top , right , bottom  } = item;\n    const apexesInArea = _isPointInArea({\n        x: left,\n        y: top\n    }, area) || _isPointInArea({\n        x: left,\n        y: bottom\n    }, area) || _isPointInArea({\n        x: right,\n        y: top\n    }, area) || _isPointInArea({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels , display  } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? PI / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === 'auto') {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left , top , right , bottom  } = item;\n    const { backdropColor  } = opts;\n    if (!isNullOrUndef(backdropColor)) {\n        const borderRadius = toTRBLCorners(opts.borderRadius);\n        const padding = toPadding(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            addRoundedRectPath(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx , options: { pointLabels  }  } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = toFont(optsAtIndex.font);\n        const { x , y , textAlign  } = item;\n        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx  } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color , lineWidth  } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return createContext(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static id = 'radialLinear';\n static defaults = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0.0\n        },\n        grid: {\n            circular: false\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: true,\n            callback: Ticks.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: undefined,\n            backdropPadding: 2,\n            display: true,\n            font: {\n                size: 10\n            },\n            callback (label) {\n                return label;\n            },\n            padding: 5,\n            centerPointLabels: false\n        }\n    };\n    static defaultRoutes = {\n        'angleLines.color': 'borderColor',\n        'pointLabels.color': 'color',\n        'ticks.color': 'color'\n    };\n    static descriptors = {\n        angleLines: {\n            _fallback: 'grid'\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.xCenter = undefined;\n         this.yCenter = undefined;\n         this.drawingArea = undefined;\n         this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(false);\n        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = callback(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = TAU / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if (isNullOrUndef(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if (isNullOrUndef(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n drawBackground() {\n        const { backgroundColor , grid: { circular  }  } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines , grid , border  } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color , lineWidth  } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n drawBorder() {}\n drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = toFont(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = toPadding(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            renderText(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n drawTitle() {}\n}\n\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\n function sorter(a, b) {\n    return a - b;\n}\n function parse(scale, input) {\n    if (isNullOrUndef(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser , round , isoWeekday  } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!isNumberFinite(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n function determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\n function addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo , hi  } = _lookup(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\n function setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\n function ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n     const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static id = 'time';\n static defaults = {\n bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            unit: false,\n            round: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n source: 'auto',\n            callback: false,\n            major: {\n                enabled: false\n            }\n        }\n    };\n constructor(props){\n        super(props);\n         this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n         this._unit = 'day';\n         this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        mergeIf(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = _filterBetween(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = _limitValue(start, 0, limit);\n        end = _limitValue(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = isNumber(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return callback(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n normalize(values) {\n        return _arrayUnique(values.sort(sorter));\n    }\n}\n\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo , hi  } = _lookupByKey(table, 'pos', val));\n        }\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo , hi  } = _lookupByKey(table, 'time', val));\n        }\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static id = 'timeseries';\n static defaults = TimeScale.defaults;\n constructor(props){\n        super(props);\n         this._table = [];\n         this._minPos = undefined;\n         this._tableRange = undefined;\n    }\n initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n buildLookupTable(timestamps) {\n        const { min , max  } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, plugin_colors as Colors, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, defaults, elements, layouts, plugins, registerables, registry, scales };\n//# sourceMappingURL=chart.js.map\n","// Season data for inner ring\nexport const seasons = [\n    { label: 'seasons.spring', value: 92, color: '#90EE90' },\n    { label: 'seasons.summer', value: 92, color: '#FFD700' },\n    { label: 'seasons.autumn', value: 91, color: '#FF8C00' },\n    { label: 'seasons.winter', value: 90, color: '#87CEEB' },\n];\n// Month data for outer ring\nexport const months = [\n    { label: 'months.march', value: 31, color: '#98FB98' },\n    { label: 'months.april', value: 30, color: '#90EE90' },\n    { label: 'months.may', value: 31, color: '#8FBC8F' },\n    { label: 'months.june', value: 30, color: '#FFEC8B' },\n    { label: 'months.july', value: 31, color: '#FFD700' },\n    { label: 'months.august', value: 31, color: '#FFA500' },\n    { label: 'months.september', value: 30, color: '#FF7F50' },\n    { label: 'months.october', value: 31, color: '#FF8C00' },\n    { label: 'months.november', value: 30, color: '#D2691E' },\n    { label: 'months.december', value: 31, color: '#87CEEB' },\n    { label: 'months.january', value: 31, color: '#4682B4' },\n    { label: 'months.february', value: 28, color: '#6495ED' },\n];\n","const ROTATION_CONFIG = {\n    // makes the label perpendicular to the radius\n    PERPENDICULAR_OFFSET: Math.PI / 2,\n};\nexport function calculateTextRotationAngle(middleAngle, perpendicular) {\n    let rotationAngle = middleAngle;\n    if (perpendicular) {\n        rotationAngle += ROTATION_CONFIG.PERPENDICULAR_OFFSET;\n    }\n    // normalize angle to be between - and \n    while (rotationAngle > Math.PI) {\n        rotationAngle -= 2 * Math.PI;\n    }\n    while (rotationAngle < -Math.PI) {\n        rotationAngle += 2 * Math.PI;\n    }\n    return rotationAngle;\n}\n","const DATASET_INDICES = { MONTHS: 0, SEASONS: 1 };\n// Constants for styling and positioning\nconst LABEL_STYLE_CONFIG = {\n    MONTH: { FONT: 'bold 13px Arial', COLOR: '#000' },\n    SEASON: { FONT: 'bold 18px Arial', COLOR: '#000' },\n};\nexport function createLabelConfiguration(multiLabels, datasetIndex, elementIndex) {\n    const labels = multiLabels[datasetIndex];\n    const text = labels[elementIndex]?.translation || '';\n    const isMonthsDataset = datasetIndex === DATASET_INDICES.MONTHS;\n    const styleConfig = isMonthsDataset ? LABEL_STYLE_CONFIG.MONTH : LABEL_STYLE_CONFIG.SEASON;\n    return {\n        text,\n        font: styleConfig.FONT,\n        color: styleConfig.COLOR,\n    };\n}\n","import { renderDatasetLabels } from './rotatedLabelsRenderer';\n/**\n * Custom Chart.js plugin for rendering rotated labels inside doughnut charts\n */\nexport const rotatedLabelsPlugin = {\n    id: 'rotatedLabels',\n    afterDatasetsDraw(chart) {\n        const context = chart.ctx;\n        const datasets = chart.config.data.datasets;\n        const multiLabels = chart.data.labels;\n        datasets.forEach((_, datasetIndex) => {\n            const datasetMeta = chart.getDatasetMeta(datasetIndex);\n            renderDatasetLabels(multiLabels, context, datasetIndex, datasetMeta.data);\n        });\n    },\n};\n","import { calculateLabelPosition } from './rotatedLabelsPosition';\nimport { calculateTextRotationAngle } from './rotatedLabelsRotation';\nimport { createLabelConfiguration } from './rotatedLabelsTextAndStyle';\nexport function renderDatasetLabels(multiLabels, context, datasetIndex, elements) {\n    elements.forEach((element, elementIndex) => {\n        const arcElement = element;\n        const labelConfiguration = createLabelConfiguration(multiLabels, datasetIndex, elementIndex);\n        renderLabel(context, datasetIndex, arcElement, labelConfiguration);\n    });\n}\nfunction renderLabel(context, datasetIndex, arcElement, configuration) {\n    if (!configuration.text) {\n        return;\n    }\n    const middleAngle = (arcElement.startAngle + arcElement.endAngle) / 2;\n    const middleRadius = (arcElement.innerRadius + arcElement.outerRadius) / 2;\n    const labelPosition = calculateLabelPosition(arcElement.x, arcElement.y, middleAngle, middleRadius);\n    context.save();\n    context.translate(labelPosition.x, labelPosition.y);\n    // only perpendicular index for the inner ring\n    const perpendicular = datasetIndex == 1;\n    const rotationAngle = calculateTextRotationAngle(middleAngle, perpendicular);\n    context.rotate(rotationAngle);\n    applyTextStyling(context, configuration);\n    context.fillText(configuration.text, 0, 0);\n    context.restore();\n}\nfunction applyTextStyling(context, configuration) {\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    context.font = configuration.font;\n    context.fillStyle = configuration.color;\n}\n","/**\n * Calculates polar-to-cartesian coordinate conversion for label placement.\n *\n * @param centerX vertical center of the doughnut chart\n * @param centerY horizontal center of the doughnut chart\n * @param middleAngle direction of an arc element (in radians)\n * @param middleRadius required distance from the center\n * @returns\n */\nexport function calculateLabelPosition(centerX, centerY, middleAngle, middleRadius) {\n    return {\n        x: centerX + Math.cos(middleAngle) * middleRadius,\n        y: centerY + Math.sin(middleAngle) * middleRadius,\n    };\n}\n","const isString = obj => typeof obj === 'string';\nconst defer = () => {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n};\nconst makeString = object => {\n  if (object == null) return '';\n  return '' + object;\n};\nconst copy = (a, s, t) => {\n  a.forEach(m => {\n    if (s[m]) t[m] = s[m];\n  });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = key => key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;\nconst canNotTraverseDeeper = object => !object || isString(object);\nconst getLastOfPath = (object, path, Empty) => {\n  const stack = !isString(path) ? path : path.split('.');\n  let stackIndex = 0;\n  while (stackIndex < stack.length - 1) {\n    if (canNotTraverseDeeper(object)) return {};\n    const key = cleanKey(stack[stackIndex]);\n    if (!object[key] && Empty) object[key] = new Empty();\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      object = object[key];\n    } else {\n      object = {};\n    }\n    ++stackIndex;\n  }\n  if (canNotTraverseDeeper(object)) return {};\n  return {\n    obj: object,\n    k: cleanKey(stack[stackIndex])\n  };\n};\nconst setPath = (object, path, newValue) => {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path, Object);\n  if (obj !== undefined || path.length === 1) {\n    obj[k] = newValue;\n    return;\n  }\n  let e = path[path.length - 1];\n  let p = path.slice(0, path.length - 1);\n  let last = getLastOfPath(object, p, Object);\n  while (last.obj === undefined && p.length) {\n    e = `${p[p.length - 1]}.${e}`;\n    p = p.slice(0, p.length - 1);\n    last = getLastOfPath(object, p, Object);\n    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {\n      last.obj = undefined;\n    }\n  }\n  last.obj[`${last.k}.${e}`] = newValue;\n};\nconst pushPath = (object, path, newValue, concat) => {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path, Object);\n  obj[k] = obj[k] || [];\n  obj[k].push(newValue);\n};\nconst getPath = (object, path) => {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path);\n  if (!obj) return undefined;\n  if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;\n  return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key) => {\n  const value = getPath(data, key);\n  if (value !== undefined) {\n    return value;\n  }\n  return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite) => {\n  for (const prop in source) {\n    if (prop !== '__proto__' && prop !== 'constructor') {\n      if (prop in target) {\n        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {\n          if (overwrite) target[prop] = source[prop];\n        } else {\n          deepExtend(target[prop], source[prop], overwrite);\n        }\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n  }\n  return target;\n};\nconst regexEscape = str => str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\nvar _entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;'\n};\nconst escape = data => {\n  if (isString(data)) {\n    return data.replace(/[&<>\"'\\/]/g, s => _entityMap[s]);\n  }\n  return data;\n};\nclass RegExpCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.regExpMap = new Map();\n    this.regExpQueue = [];\n  }\n  getRegExp(pattern) {\n    const regExpFromCache = this.regExpMap.get(pattern);\n    if (regExpFromCache !== undefined) {\n      return regExpFromCache;\n    }\n    const regExpNew = new RegExp(pattern);\n    if (this.regExpQueue.length === this.capacity) {\n      this.regExpMap.delete(this.regExpQueue.shift());\n    }\n    this.regExpMap.set(pattern, regExpNew);\n    this.regExpQueue.push(pattern);\n    return regExpNew;\n  }\n}\nconst chars = [' ', ',', '?', '!', ';'];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator) => {\n  nsSeparator = nsSeparator || '';\n  keySeparator = keySeparator || '';\n  const possibleChars = chars.filter(c => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n  if (possibleChars.length === 0) return true;\n  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map(c => c === '?' ? '\\\\?' : c).join('|')})`);\n  let matched = !r.test(key);\n  if (!matched) {\n    const ki = key.indexOf(keySeparator);\n    if (ki > 0 && !r.test(key.substring(0, ki))) {\n      matched = true;\n    }\n  }\n  return matched;\n};\nconst deepFind = (obj, path, keySeparator = '.') => {\n  if (!obj) return undefined;\n  if (obj[path]) {\n    if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;\n    return obj[path];\n  }\n  const tokens = path.split(keySeparator);\n  let current = obj;\n  for (let i = 0; i < tokens.length;) {\n    if (!current || typeof current !== 'object') {\n      return undefined;\n    }\n    let next;\n    let nextPath = '';\n    for (let j = i; j < tokens.length; ++j) {\n      if (j !== i) {\n        nextPath += keySeparator;\n      }\n      nextPath += tokens[j];\n      next = current[nextPath];\n      if (next !== undefined) {\n        if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n          continue;\n        }\n        i += j - i + 1;\n        break;\n      }\n    }\n    current = next;\n  }\n  return current;\n};\nconst getCleanedCode = code => code?.replace('_', '-');\n\nconst consoleLogger = {\n  type: 'logger',\n  log(args) {\n    this.output('log', args);\n  },\n  warn(args) {\n    this.output('warn', args);\n  },\n  error(args) {\n    this.output('error', args);\n  },\n  output(type, args) {\n    console?.[type]?.apply?.(console, args);\n  }\n};\nclass Logger {\n  constructor(concreteLogger, options = {}) {\n    this.init(concreteLogger, options);\n  }\n  init(concreteLogger, options = {}) {\n    this.prefix = options.prefix || 'i18next:';\n    this.logger = concreteLogger || consoleLogger;\n    this.options = options;\n    this.debug = options.debug;\n  }\n  log(...args) {\n    return this.forward(args, 'log', '', true);\n  }\n  warn(...args) {\n    return this.forward(args, 'warn', '', true);\n  }\n  error(...args) {\n    return this.forward(args, 'error', '');\n  }\n  deprecate(...args) {\n    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n  }\n  forward(args, lvl, prefix, debugOnly) {\n    if (debugOnly && !this.debug) return null;\n    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;\n    return this.logger[lvl](args);\n  }\n  create(moduleName) {\n    return new Logger(this.logger, {\n      ...{\n        prefix: `${this.prefix}:${moduleName}:`\n      },\n      ...this.options\n    });\n  }\n  clone(options) {\n    options = options || this.options;\n    options.prefix = options.prefix || this.prefix;\n    return new Logger(this.logger, options);\n  }\n}\nvar baseLogger = new Logger();\n\nclass EventEmitter {\n  constructor() {\n    this.observers = {};\n  }\n  on(events, listener) {\n    events.split(' ').forEach(event => {\n      if (!this.observers[event]) this.observers[event] = new Map();\n      const numListeners = this.observers[event].get(listener) || 0;\n      this.observers[event].set(listener, numListeners + 1);\n    });\n    return this;\n  }\n  off(event, listener) {\n    if (!this.observers[event]) return;\n    if (!listener) {\n      delete this.observers[event];\n      return;\n    }\n    this.observers[event].delete(listener);\n  }\n  emit(event, ...args) {\n    if (this.observers[event]) {\n      const cloned = Array.from(this.observers[event].entries());\n      cloned.forEach(([observer, numTimesAdded]) => {\n        for (let i = 0; i < numTimesAdded; i++) {\n          observer(...args);\n        }\n      });\n    }\n    if (this.observers['*']) {\n      const cloned = Array.from(this.observers['*'].entries());\n      cloned.forEach(([observer, numTimesAdded]) => {\n        for (let i = 0; i < numTimesAdded; i++) {\n          observer.apply(observer, [event, ...args]);\n        }\n      });\n    }\n  }\n}\n\nclass ResourceStore extends EventEmitter {\n  constructor(data, options = {\n    ns: ['translation'],\n    defaultNS: 'translation'\n  }) {\n    super();\n    this.data = data || {};\n    this.options = options;\n    if (this.options.keySeparator === undefined) {\n      this.options.keySeparator = '.';\n    }\n    if (this.options.ignoreJSONStructure === undefined) {\n      this.options.ignoreJSONStructure = true;\n    }\n  }\n  addNamespaces(ns) {\n    if (this.options.ns.indexOf(ns) < 0) {\n      this.options.ns.push(ns);\n    }\n  }\n  removeNamespaces(ns) {\n    const index = this.options.ns.indexOf(ns);\n    if (index > -1) {\n      this.options.ns.splice(index, 1);\n    }\n  }\n  getResource(lng, ns, key, options = {}) {\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n    let path;\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n    } else {\n      path = [lng, ns];\n      if (key) {\n        if (Array.isArray(key)) {\n          path.push(...key);\n        } else if (isString(key) && keySeparator) {\n          path.push(...key.split(keySeparator));\n        } else {\n          path.push(key);\n        }\n      }\n    }\n    const result = getPath(this.data, path);\n    if (!result && !ns && !key && lng.indexOf('.') > -1) {\n      lng = path[0];\n      ns = path[1];\n      key = path.slice(2).join('.');\n    }\n    if (result || !ignoreJSONStructure || !isString(key)) return result;\n    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);\n  }\n  addResource(lng, ns, key, value, options = {\n    silent: false\n  }) {\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    let path = [lng, ns];\n    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n      value = ns;\n      ns = path[1];\n    }\n    this.addNamespaces(ns);\n    setPath(this.data, path, value);\n    if (!options.silent) this.emit('added', lng, ns, key, value);\n  }\n  addResources(lng, ns, resources, options = {\n    silent: false\n  }) {\n    for (const m in resources) {\n      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n        silent: true\n      });\n    }\n    if (!options.silent) this.emit('added', lng, ns, resources);\n  }\n  addResourceBundle(lng, ns, resources, deep, overwrite, options = {\n    silent: false,\n    skipCopy: false\n  }) {\n    let path = [lng, ns];\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n      deep = resources;\n      resources = ns;\n      ns = path[1];\n    }\n    this.addNamespaces(ns);\n    let pack = getPath(this.data, path) || {};\n    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n    if (deep) {\n      deepExtend(pack, resources, overwrite);\n    } else {\n      pack = {\n        ...pack,\n        ...resources\n      };\n    }\n    setPath(this.data, path, pack);\n    if (!options.silent) this.emit('added', lng, ns, resources);\n  }\n  removeResourceBundle(lng, ns) {\n    if (this.hasResourceBundle(lng, ns)) {\n      delete this.data[lng][ns];\n    }\n    this.removeNamespaces(ns);\n    this.emit('removed', lng, ns);\n  }\n  hasResourceBundle(lng, ns) {\n    return this.getResource(lng, ns) !== undefined;\n  }\n  getResourceBundle(lng, ns) {\n    if (!ns) ns = this.options.defaultNS;\n    return this.getResource(lng, ns);\n  }\n  getDataByLanguage(lng) {\n    return this.data[lng];\n  }\n  hasLanguageSomeTranslations(lng) {\n    const data = this.getDataByLanguage(lng);\n    const n = data && Object.keys(data) || [];\n    return !!n.find(v => data[v] && Object.keys(data[v]).length > 0);\n  }\n  toJSON() {\n    return this.data;\n  }\n}\n\nvar postProcessor = {\n  processors: {},\n  addPostProcessor(module) {\n    this.processors[module.name] = module;\n  },\n  handle(processors, value, key, options, translator) {\n    processors.forEach(processor => {\n      value = this.processors[processor]?.process(value, key, options, translator) ?? value;\n    });\n    return value;\n  }\n};\n\nconst PATH_KEY = Symbol('i18next/PATH_KEY');\nfunction createProxy() {\n  const state = [];\n  const handler = Object.create(null);\n  let proxy;\n  handler.get = (target, key) => {\n    proxy?.revoke?.();\n    if (key === PATH_KEY) return state;\n    state.push(key);\n    proxy = Proxy.revocable(target, handler);\n    return proxy.proxy;\n  };\n  return Proxy.revocable(Object.create(null), handler).proxy;\n}\nfunction keysFromSelector(selector, opts) {\n  const {\n    [PATH_KEY]: path\n  } = selector(createProxy());\n  return path.join(opts?.keySeparator ?? '.');\n}\n\nconst checkedLoadedFor = {};\nconst shouldHandleAsObject = res => !isString(res) && typeof res !== 'boolean' && typeof res !== 'number';\nclass Translator extends EventEmitter {\n  constructor(services, options = {}) {\n    super();\n    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, this);\n    this.options = options;\n    if (this.options.keySeparator === undefined) {\n      this.options.keySeparator = '.';\n    }\n    this.logger = baseLogger.create('translator');\n  }\n  changeLanguage(lng) {\n    if (lng) this.language = lng;\n  }\n  exists(key, o = {\n    interpolation: {}\n  }) {\n    const opt = {\n      ...o\n    };\n    if (key == null) return false;\n    const resolved = this.resolve(key, opt);\n    if (resolved?.res === undefined) return false;\n    const isObject = shouldHandleAsObject(resolved.res);\n    if (opt.returnObjects === false && isObject) {\n      return false;\n    }\n    return true;\n  }\n  extractFromKey(key, opt) {\n    let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n    if (nsSeparator === undefined) nsSeparator = ':';\n    const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n    let namespaces = opt.ns || this.options.defaultNS || [];\n    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n      const m = key.match(this.interpolator.nestingRegexp);\n      if (m && m.length > 0) {\n        return {\n          key,\n          namespaces: isString(namespaces) ? [namespaces] : namespaces\n        };\n      }\n      const parts = key.split(nsSeparator);\n      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n      key = parts.join(keySeparator);\n    }\n    return {\n      key,\n      namespaces: isString(namespaces) ? [namespaces] : namespaces\n    };\n  }\n  translate(keys, o, lastKey) {\n    let opt = typeof o === 'object' ? {\n      ...o\n    } : o;\n    if (typeof opt !== 'object' && this.options.overloadTranslationOptionHandler) {\n      opt = this.options.overloadTranslationOptionHandler(arguments);\n    }\n    if (typeof opt === 'object') opt = {\n      ...opt\n    };\n    if (!opt) opt = {};\n    if (keys == null) return '';\n    if (typeof keys === 'function') keys = keysFromSelector(keys, {\n      ...this.options,\n      ...opt\n    });\n    if (!Array.isArray(keys)) keys = [String(keys)];\n    const returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;\n    const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n    const {\n      key,\n      namespaces\n    } = this.extractFromKey(keys[keys.length - 1], opt);\n    const namespace = namespaces[namespaces.length - 1];\n    let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n    if (nsSeparator === undefined) nsSeparator = ':';\n    const lng = opt.lng || this.language;\n    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n    if (lng?.toLowerCase() === 'cimode') {\n      if (appendNamespaceToCIMode) {\n        if (returnDetails) {\n          return {\n            res: `${namespace}${nsSeparator}${key}`,\n            usedKey: key,\n            exactUsedKey: key,\n            usedLng: lng,\n            usedNS: namespace,\n            usedParams: this.getUsedParamsDetails(opt)\n          };\n        }\n        return `${namespace}${nsSeparator}${key}`;\n      }\n      if (returnDetails) {\n        return {\n          res: key,\n          usedKey: key,\n          exactUsedKey: key,\n          usedLng: lng,\n          usedNS: namespace,\n          usedParams: this.getUsedParamsDetails(opt)\n        };\n      }\n      return key;\n    }\n    const resolved = this.resolve(keys, opt);\n    let res = resolved?.res;\n    const resUsedKey = resolved?.usedKey || key;\n    const resExactUsedKey = resolved?.exactUsedKey || key;\n    const noObject = ['[object Number]', '[object Function]', '[object RegExp]'];\n    const joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;\n    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n    const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n    const hasDefaultValue = Translator.hasDefaultValue(opt);\n    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : '';\n    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {\n      ordinal: false\n    }) : '';\n    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;\n    let resForObjHndl = res;\n    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {\n      resForObjHndl = defaultValue;\n    }\n    const handleAsObject = shouldHandleAsObject(resForObjHndl);\n    const resType = Object.prototype.toString.apply(resForObjHndl);\n    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {\n      if (!opt.returnObjects && !this.options.returnObjects) {\n        if (!this.options.returnedObjectHandler) {\n          this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n        }\n        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {\n          ...opt,\n          ns: namespaces\n        }) : `key '${key} (${this.language})' returned an object instead of string.`;\n        if (returnDetails) {\n          resolved.res = r;\n          resolved.usedParams = this.getUsedParamsDetails(opt);\n          return resolved;\n        }\n        return r;\n      }\n      if (keySeparator) {\n        const resTypeIsArray = Array.isArray(resForObjHndl);\n        const copy = resTypeIsArray ? [] : {};\n        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n        for (const m in resForObjHndl) {\n          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {\n            const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n            if (hasDefaultValue && !res) {\n              copy[m] = this.translate(deepKey, {\n                ...opt,\n                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,\n                ...{\n                  joinArrays: false,\n                  ns: namespaces\n                }\n              });\n            } else {\n              copy[m] = this.translate(deepKey, {\n                ...opt,\n                ...{\n                  joinArrays: false,\n                  ns: namespaces\n                }\n              });\n            }\n            if (copy[m] === deepKey) copy[m] = resForObjHndl[m];\n          }\n        }\n        res = copy;\n      }\n    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n      res = res.join(joinArrays);\n      if (res) res = this.extendTranslation(res, keys, opt, lastKey);\n    } else {\n      let usedDefault = false;\n      let usedKey = false;\n      if (!this.isValidLookup(res) && hasDefaultValue) {\n        usedDefault = true;\n        res = defaultValue;\n      }\n      if (!this.isValidLookup(res)) {\n        usedKey = true;\n        res = key;\n      }\n      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n      if (usedKey || usedDefault || updateMissing) {\n        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n        if (keySeparator) {\n          const fk = this.resolve(key, {\n            ...opt,\n            keySeparator: false\n          });\n          if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n        }\n        let lngs = [];\n        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);\n        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n          for (let i = 0; i < fallbackLngs.length; i++) {\n            lngs.push(fallbackLngs[i]);\n          }\n        } else if (this.options.saveMissingTo === 'all') {\n          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);\n        } else {\n          lngs.push(opt.lng || this.language);\n        }\n        const send = (l, k, specificDefaultValue) => {\n          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n          if (this.options.missingKeyHandler) {\n            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);\n          } else if (this.backendConnector?.saveMissing) {\n            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);\n          }\n          this.emit('missingKey', l, namespace, k, res);\n        };\n        if (this.options.saveMissing) {\n          if (this.options.saveMissingPlurals && needsPluralHandling) {\n            lngs.forEach(language => {\n              const suffixes = this.pluralResolver.getSuffixes(language, opt);\n              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                suffixes.push(`${this.options.pluralSeparator}zero`);\n              }\n              suffixes.forEach(suffix => {\n                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);\n              });\n            });\n          } else {\n            send(lngs, key, defaultValue);\n          }\n        }\n      }\n      res = this.extendTranslation(res, keys, opt, resolved, lastKey);\n      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {\n        res = `${namespace}${nsSeparator}${key}`;\n      }\n      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : undefined, opt);\n      }\n    }\n    if (returnDetails) {\n      resolved.res = res;\n      resolved.usedParams = this.getUsedParamsDetails(opt);\n      return resolved;\n    }\n    return res;\n  }\n  extendTranslation(res, key, opt, resolved, lastKey) {\n    if (this.i18nFormat?.parse) {\n      res = this.i18nFormat.parse(res, {\n        ...this.options.interpolation.defaultVariables,\n        ...opt\n      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n        resolved\n      });\n    } else if (!opt.skipInterpolation) {\n      if (opt.interpolation) this.interpolator.init({\n        ...opt,\n        ...{\n          interpolation: {\n            ...this.options.interpolation,\n            ...opt.interpolation\n          }\n        }\n      });\n      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n      let nestBef;\n      if (skipOnVariables) {\n        const nb = res.match(this.interpolator.nestingRegexp);\n        nestBef = nb && nb.length;\n      }\n      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;\n      if (this.options.interpolation.defaultVariables) data = {\n        ...this.options.interpolation.defaultVariables,\n        ...data\n      };\n      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);\n      if (skipOnVariables) {\n        const na = res.match(this.interpolator.nestingRegexp);\n        const nestAft = na && na.length;\n        if (nestBef < nestAft) opt.nest = false;\n      }\n      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;\n      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {\n        if (lastKey?.[0] === args[0] && !opt.context) {\n          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n          return null;\n        }\n        return this.translate(...args, key);\n      }, opt);\n      if (opt.interpolation) this.interpolator.reset();\n    }\n    const postProcess = opt.postProcess || this.options.postProcess;\n    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;\n    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {\n      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n        i18nResolved: {\n          ...resolved,\n          usedParams: this.getUsedParamsDetails(opt)\n        },\n        ...opt\n      } : opt, this);\n    }\n    return res;\n  }\n  resolve(keys, opt = {}) {\n    let found;\n    let usedKey;\n    let exactUsedKey;\n    let usedLng;\n    let usedNS;\n    if (isString(keys)) keys = [keys];\n    keys.forEach(k => {\n      if (this.isValidLookup(found)) return;\n      const extracted = this.extractFromKey(k, opt);\n      const key = extracted.key;\n      usedKey = key;\n      let namespaces = extracted.namespaces;\n      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n      const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n      const needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === 'number') && opt.context !== '';\n      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);\n      namespaces.forEach(ns => {\n        if (this.isValidLookup(found)) return;\n        usedNS = ns;\n        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {\n          checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n          this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(', ')}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n        }\n        codes.forEach(code => {\n          if (this.isValidLookup(found)) return;\n          usedLng = code;\n          const finalKeys = [key];\n          if (this.i18nFormat?.addLookupKeys) {\n            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);\n          } else {\n            let pluralSuffix;\n            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);\n            const zeroSuffix = `${this.options.pluralSeparator}zero`;\n            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n            if (needsPluralHandling) {\n              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n              }\n              finalKeys.push(key + pluralSuffix);\n              if (needsZeroSuffixLookup) {\n                finalKeys.push(key + zeroSuffix);\n              }\n            }\n            if (needsContextHandling) {\n              const contextKey = `${key}${this.options.contextSeparator || '_'}${opt.context}`;\n              finalKeys.push(contextKey);\n              if (needsPluralHandling) {\n                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                }\n                finalKeys.push(contextKey + pluralSuffix);\n                if (needsZeroSuffixLookup) {\n                  finalKeys.push(contextKey + zeroSuffix);\n                }\n              }\n            }\n          }\n          let possibleKey;\n          while (possibleKey = finalKeys.pop()) {\n            if (!this.isValidLookup(found)) {\n              exactUsedKey = possibleKey;\n              found = this.getResource(code, ns, possibleKey, opt);\n            }\n          }\n        });\n      });\n    });\n    return {\n      res: found,\n      usedKey,\n      exactUsedKey,\n      usedLng,\n      usedNS\n    };\n  }\n  isValidLookup(res) {\n    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n  }\n  getResource(code, ns, key, options = {}) {\n    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n    return this.resourceStore.getResource(code, ns, key, options);\n  }\n  getUsedParamsDetails(options = {}) {\n    const optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];\n    const useOptionsReplaceForData = options.replace && !isString(options.replace);\n    let data = useOptionsReplaceForData ? options.replace : options;\n    if (useOptionsReplaceForData && typeof options.count !== 'undefined') {\n      data.count = options.count;\n    }\n    if (this.options.interpolation.defaultVariables) {\n      data = {\n        ...this.options.interpolation.defaultVariables,\n        ...data\n      };\n    }\n    if (!useOptionsReplaceForData) {\n      data = {\n        ...data\n      };\n      for (const key of optionsKeys) {\n        delete data[key];\n      }\n    }\n    return data;\n  }\n  static hasDefaultValue(options) {\n    const prefix = 'defaultValue';\n    for (const option in options) {\n      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nclass LanguageUtil {\n  constructor(options) {\n    this.options = options;\n    this.supportedLngs = this.options.supportedLngs || false;\n    this.logger = baseLogger.create('languageUtils');\n  }\n  getScriptPartFromCode(code) {\n    code = getCleanedCode(code);\n    if (!code || code.indexOf('-') < 0) return null;\n    const p = code.split('-');\n    if (p.length === 2) return null;\n    p.pop();\n    if (p[p.length - 1].toLowerCase() === 'x') return null;\n    return this.formatLanguageCode(p.join('-'));\n  }\n  getLanguagePartFromCode(code) {\n    code = getCleanedCode(code);\n    if (!code || code.indexOf('-') < 0) return code;\n    const p = code.split('-');\n    return this.formatLanguageCode(p[0]);\n  }\n  formatLanguageCode(code) {\n    if (isString(code) && code.indexOf('-') > -1) {\n      let formattedCode;\n      try {\n        formattedCode = Intl.getCanonicalLocales(code)[0];\n      } catch (e) {}\n      if (formattedCode && this.options.lowerCaseLng) {\n        formattedCode = formattedCode.toLowerCase();\n      }\n      if (formattedCode) return formattedCode;\n      if (this.options.lowerCaseLng) {\n        return code.toLowerCase();\n      }\n      return code;\n    }\n    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n  }\n  isSupportedCode(code) {\n    if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n      code = this.getLanguagePartFromCode(code);\n    }\n    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n  }\n  getBestMatchFromCodes(codes) {\n    if (!codes) return null;\n    let found;\n    codes.forEach(code => {\n      if (found) return;\n      const cleanedLng = this.formatLanguageCode(code);\n      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n    });\n    if (!found && this.options.supportedLngs) {\n      codes.forEach(code => {\n        if (found) return;\n        const lngScOnly = this.getScriptPartFromCode(code);\n        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;\n        const lngOnly = this.getLanguagePartFromCode(code);\n        if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n        found = this.options.supportedLngs.find(supportedLng => {\n          if (supportedLng === lngOnly) return supportedLng;\n          if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;\n          if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;\n          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n        });\n      });\n    }\n    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n    return found;\n  }\n  getFallbackCodes(fallbacks, code) {\n    if (!fallbacks) return [];\n    if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n    if (isString(fallbacks)) fallbacks = [fallbacks];\n    if (Array.isArray(fallbacks)) return fallbacks;\n    if (!code) return fallbacks.default || [];\n    let found = fallbacks[code];\n    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n    if (!found) found = fallbacks[this.formatLanguageCode(code)];\n    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n    if (!found) found = fallbacks.default;\n    return found || [];\n  }\n  toResolveHierarchy(code, fallbackCode) {\n    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);\n    const codes = [];\n    const addCode = c => {\n      if (!c) return;\n      if (this.isSupportedCode(c)) {\n        codes.push(c);\n      } else {\n        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n      }\n    };\n    if (isString(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {\n      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n    } else if (isString(code)) {\n      addCode(this.formatLanguageCode(code));\n    }\n    fallbackCodes.forEach(fc => {\n      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n    });\n    return codes;\n  }\n}\n\nconst suffixesOrder = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  few: 3,\n  many: 4,\n  other: 5\n};\nconst dummyRule = {\n  select: count => count === 1 ? 'one' : 'other',\n  resolvedOptions: () => ({\n    pluralCategories: ['one', 'other']\n  })\n};\nclass PluralResolver {\n  constructor(languageUtils, options = {}) {\n    this.languageUtils = languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('pluralResolver');\n    this.pluralRulesCache = {};\n  }\n  clearCache() {\n    this.pluralRulesCache = {};\n  }\n  getRule(code, options = {}) {\n    const cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);\n    const type = options.ordinal ? 'ordinal' : 'cardinal';\n    const cacheKey = JSON.stringify({\n      cleanedCode,\n      type\n    });\n    if (cacheKey in this.pluralRulesCache) {\n      return this.pluralRulesCache[cacheKey];\n    }\n    let rule;\n    try {\n      rule = new Intl.PluralRules(cleanedCode, {\n        type\n      });\n    } catch (err) {\n      if (!Intl) {\n        this.logger.error('No Intl support, please use an Intl polyfill!');\n        return dummyRule;\n      }\n      if (!code.match(/-|_/)) return dummyRule;\n      const lngPart = this.languageUtils.getLanguagePartFromCode(code);\n      rule = this.getRule(lngPart, options);\n    }\n    this.pluralRulesCache[cacheKey] = rule;\n    return rule;\n  }\n  needsPlural(code, options = {}) {\n    let rule = this.getRule(code, options);\n    if (!rule) rule = this.getRule('dev', options);\n    return rule?.resolvedOptions().pluralCategories.length > 1;\n  }\n  getPluralFormsOfKey(code, key, options = {}) {\n    return this.getSuffixes(code, options).map(suffix => `${key}${suffix}`);\n  }\n  getSuffixes(code, options = {}) {\n    let rule = this.getRule(code, options);\n    if (!rule) rule = this.getRule('dev', options);\n    if (!rule) return [];\n    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map(pluralCategory => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);\n  }\n  getSuffix(code, count, options = {}) {\n    const rule = this.getRule(code, options);\n    if (rule) {\n      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;\n    }\n    this.logger.warn(`no plural rule found for: ${code}`);\n    return this.getSuffix('dev', count, options);\n  }\n}\n\nconst deepFindWithDefaults = (data, defaultData, key, keySeparator = '.', ignoreJSONStructure = true) => {\n  let path = getPathWithDefaults(data, defaultData, key);\n  if (!path && ignoreJSONStructure && isString(key)) {\n    path = deepFind(data, key, keySeparator);\n    if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n  }\n  return path;\n};\nconst regexSafe = val => val.replace(/\\$/g, '$$$$');\nclass Interpolator {\n  constructor(options = {}) {\n    this.logger = baseLogger.create('interpolator');\n    this.options = options;\n    this.format = options?.interpolation?.format || (value => value);\n    this.init(options);\n  }\n  init(options = {}) {\n    if (!options.interpolation) options.interpolation = {\n      escapeValue: true\n    };\n    const {\n      escape: escape$1,\n      escapeValue,\n      useRawValueToEscape,\n      prefix,\n      prefixEscaped,\n      suffix,\n      suffixEscaped,\n      formatSeparator,\n      unescapeSuffix,\n      unescapePrefix,\n      nestingPrefix,\n      nestingPrefixEscaped,\n      nestingSuffix,\n      nestingSuffixEscaped,\n      nestingOptionsSeparator,\n      maxReplaces,\n      alwaysFormat\n    } = options.interpolation;\n    this.escape = escape$1 !== undefined ? escape$1 : escape;\n    this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n    this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';\n    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';\n    this.formatSeparator = formatSeparator || ',';\n    this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';\n    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');\n    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');\n    this.nestingOptionsSeparator = nestingOptionsSeparator || ',';\n    this.maxReplaces = maxReplaces || 1000;\n    this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n    this.resetRegExp();\n  }\n  reset() {\n    if (this.options) this.init(this.options);\n  }\n  resetRegExp() {\n    const getOrResetRegExp = (existingRegExp, pattern) => {\n      if (existingRegExp?.source === pattern) {\n        existingRegExp.lastIndex = 0;\n        return existingRegExp;\n      }\n      return new RegExp(pattern, 'g');\n    };\n    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()\"']+|\"[^\"]*\"|'[^']*'|\\\\((?:[^()]|\"[^\"]*\"|'[^']*')*\\\\))*?)${this.nestingSuffix}`);\n  }\n  interpolate(str, data, lng, options) {\n    let match;\n    let value;\n    let replaces;\n    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n    const handleFormat = key => {\n      if (key.indexOf(this.formatSeparator) < 0) {\n        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n        return this.alwaysFormat ? this.format(path, undefined, lng, {\n          ...options,\n          ...data,\n          interpolationkey: key\n        }) : path;\n      }\n      const p = key.split(this.formatSeparator);\n      const k = p.shift().trim();\n      const f = p.join(this.formatSeparator).trim();\n      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n        ...options,\n        ...data,\n        interpolationkey: k\n      });\n    };\n    this.resetRegExp();\n    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;\n    const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n    const todos = [{\n      regex: this.regexpUnescape,\n      safeValue: val => regexSafe(val)\n    }, {\n      regex: this.regexp,\n      safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n    }];\n    todos.forEach(todo => {\n      replaces = 0;\n      while (match = todo.regex.exec(str)) {\n        const matchedVar = match[1].trim();\n        value = handleFormat(matchedVar);\n        if (value === undefined) {\n          if (typeof missingInterpolationHandler === 'function') {\n            const temp = missingInterpolationHandler(str, match, options);\n            value = isString(temp) ? temp : '';\n          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n            value = '';\n          } else if (skipOnVariables) {\n            value = match[0];\n            continue;\n          } else {\n            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n            value = '';\n          }\n        } else if (!isString(value) && !this.useRawValueToEscape) {\n          value = makeString(value);\n        }\n        const safeValue = todo.safeValue(value);\n        str = str.replace(match[0], safeValue);\n        if (skipOnVariables) {\n          todo.regex.lastIndex += value.length;\n          todo.regex.lastIndex -= match[0].length;\n        } else {\n          todo.regex.lastIndex = 0;\n        }\n        replaces++;\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n    });\n    return str;\n  }\n  nest(str, fc, options = {}) {\n    let match;\n    let value;\n    let clonedOptions;\n    const handleHasOptions = (key, inheritedOptions) => {\n      const sep = this.nestingOptionsSeparator;\n      if (key.indexOf(sep) < 0) return key;\n      const c = key.split(new RegExp(`${sep}[ ]*{`));\n      let optionsString = `{${c[1]}`;\n      key = c[0];\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      const matchedSingleQuotes = optionsString.match(/'/g);\n      const matchedDoubleQuotes = optionsString.match(/\"/g);\n      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n        optionsString = optionsString.replace(/'/g, '\"');\n      }\n      try {\n        clonedOptions = JSON.parse(optionsString);\n        if (inheritedOptions) clonedOptions = {\n          ...inheritedOptions,\n          ...clonedOptions\n        };\n      } catch (e) {\n        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n        return `${key}${sep}${optionsString}`;\n      }\n      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n      return key;\n    };\n    while (match = this.nestingRegexp.exec(str)) {\n      let formatters = [];\n      clonedOptions = {\n        ...options\n      };\n      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n      clonedOptions.applyPostProcessor = false;\n      delete clonedOptions.defaultValue;\n      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf('}') + 1 : match[1].indexOf(this.formatSeparator);\n      if (keyEndIndex !== -1) {\n        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map(elem => elem.trim()).filter(Boolean);\n        match[1] = match[1].slice(0, keyEndIndex);\n      }\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n      if (value && match[0] === str && !isString(value)) return value;\n      if (!isString(value)) value = makeString(value);\n      if (!value) {\n        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n        value = '';\n      }\n      if (formatters.length) {\n        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {\n          ...options,\n          interpolationkey: match[1].trim()\n        }), value.trim());\n      }\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n    return str;\n  }\n}\n\nconst parseFormatStr = formatStr => {\n  let formatName = formatStr.toLowerCase().trim();\n  const formatOptions = {};\n  if (formatStr.indexOf('(') > -1) {\n    const p = formatStr.split('(');\n    formatName = p[0].toLowerCase().trim();\n    const optStr = p[1].substring(0, p[1].length - 1);\n    if (formatName === 'currency' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.range) formatOptions.range = optStr.trim();\n    } else {\n      const opts = optStr.split(';');\n      opts.forEach(opt => {\n        if (opt) {\n          const [key, ...rest] = opt.split(':');\n          const val = rest.join(':').trim().replace(/^'+|'+$/g, '');\n          const trimmedKey = key.trim();\n          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n          if (val === 'false') formatOptions[trimmedKey] = false;\n          if (val === 'true') formatOptions[trimmedKey] = true;\n          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n        }\n      });\n    }\n  }\n  return {\n    formatName,\n    formatOptions\n  };\n};\nconst createCachedFormatter = fn => {\n  const cache = {};\n  return (v, l, o) => {\n    let optForCache = o;\n    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {\n      optForCache = {\n        ...optForCache,\n        [o.interpolationkey]: undefined\n      };\n    }\n    const key = l + JSON.stringify(optForCache);\n    let frm = cache[key];\n    if (!frm) {\n      frm = fn(getCleanedCode(l), o);\n      cache[key] = frm;\n    }\n    return frm(v);\n  };\n};\nconst createNonCachedFormatter = fn => (v, l, o) => fn(getCleanedCode(l), o)(v);\nclass Formatter {\n  constructor(options = {}) {\n    this.logger = baseLogger.create('formatter');\n    this.options = options;\n    this.init(options);\n  }\n  init(services, options = {\n    interpolation: {}\n  }) {\n    this.formatSeparator = options.interpolation.formatSeparator || ',';\n    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;\n    this.formats = {\n      number: cf((lng, opt) => {\n        const formatter = new Intl.NumberFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      }),\n      currency: cf((lng, opt) => {\n        const formatter = new Intl.NumberFormat(lng, {\n          ...opt,\n          style: 'currency'\n        });\n        return val => formatter.format(val);\n      }),\n      datetime: cf((lng, opt) => {\n        const formatter = new Intl.DateTimeFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      }),\n      relativetime: cf((lng, opt) => {\n        const formatter = new Intl.RelativeTimeFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val, opt.range || 'day');\n      }),\n      list: cf((lng, opt) => {\n        const formatter = new Intl.ListFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      })\n    };\n  }\n  add(name, fc) {\n    this.formats[name.toLowerCase().trim()] = fc;\n  }\n  addCached(name, fc) {\n    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n  }\n  format(value, format, lng, options = {}) {\n    const formats = format.split(this.formatSeparator);\n    if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find(f => f.indexOf(')') > -1)) {\n      const lastIndex = formats.findIndex(f => f.indexOf(')') > -1);\n      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);\n    }\n    const result = formats.reduce((mem, f) => {\n      const {\n        formatName,\n        formatOptions\n      } = parseFormatStr(f);\n      if (this.formats[formatName]) {\n        let formatted = mem;\n        try {\n          const valOptions = options?.formatParams?.[options.interpolationkey] || {};\n          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n          formatted = this.formats[formatName](mem, l, {\n            ...formatOptions,\n            ...options,\n            ...valOptions\n          });\n        } catch (error) {\n          this.logger.warn(error);\n        }\n        return formatted;\n      } else {\n        this.logger.warn(`there was no format function for ${formatName}`);\n      }\n      return mem;\n    }, value);\n    return result;\n  }\n}\n\nconst removePending = (q, name) => {\n  if (q.pending[name] !== undefined) {\n    delete q.pending[name];\n    q.pendingCount--;\n  }\n};\nclass Connector extends EventEmitter {\n  constructor(backend, store, services, options = {}) {\n    super();\n    this.backend = backend;\n    this.store = store;\n    this.services = services;\n    this.languageUtils = services.languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('backendConnector');\n    this.waitingReads = [];\n    this.maxParallelReads = options.maxParallelReads || 10;\n    this.readingCalls = 0;\n    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n    this.state = {};\n    this.queue = [];\n    this.backend?.init?.(services, options.backend, options);\n  }\n  queueLoad(languages, namespaces, options, callback) {\n    const toLoad = {};\n    const pending = {};\n    const toLoadLanguages = {};\n    const toLoadNamespaces = {};\n    languages.forEach(lng => {\n      let hasAllNamespaces = true;\n      namespaces.forEach(ns => {\n        const name = `${lng}|${ns}`;\n        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n          this.state[name] = 2;\n        } else if (this.state[name] < 0) ; else if (this.state[name] === 1) {\n          if (pending[name] === undefined) pending[name] = true;\n        } else {\n          this.state[name] = 1;\n          hasAllNamespaces = false;\n          if (pending[name] === undefined) pending[name] = true;\n          if (toLoad[name] === undefined) toLoad[name] = true;\n          if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n        }\n      });\n      if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n    });\n    if (Object.keys(toLoad).length || Object.keys(pending).length) {\n      this.queue.push({\n        pending,\n        pendingCount: Object.keys(pending).length,\n        loaded: {},\n        errors: [],\n        callback\n      });\n    }\n    return {\n      toLoad: Object.keys(toLoad),\n      pending: Object.keys(pending),\n      toLoadLanguages: Object.keys(toLoadLanguages),\n      toLoadNamespaces: Object.keys(toLoadNamespaces)\n    };\n  }\n  loaded(name, err, data) {\n    const s = name.split('|');\n    const lng = s[0];\n    const ns = s[1];\n    if (err) this.emit('failedLoading', lng, ns, err);\n    if (!err && data) {\n      this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n        skipCopy: true\n      });\n    }\n    this.state[name] = err ? -1 : 2;\n    if (err && data) this.state[name] = 0;\n    const loaded = {};\n    this.queue.forEach(q => {\n      pushPath(q.loaded, [lng], ns);\n      removePending(q, name);\n      if (err) q.errors.push(err);\n      if (q.pendingCount === 0 && !q.done) {\n        Object.keys(q.loaded).forEach(l => {\n          if (!loaded[l]) loaded[l] = {};\n          const loadedKeys = q.loaded[l];\n          if (loadedKeys.length) {\n            loadedKeys.forEach(n => {\n              if (loaded[l][n] === undefined) loaded[l][n] = true;\n            });\n          }\n        });\n        q.done = true;\n        if (q.errors.length) {\n          q.callback(q.errors);\n        } else {\n          q.callback();\n        }\n      }\n    });\n    this.emit('loaded', loaded);\n    this.queue = this.queue.filter(q => !q.done);\n  }\n  read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {\n    if (!lng.length) return callback(null, {});\n    if (this.readingCalls >= this.maxParallelReads) {\n      this.waitingReads.push({\n        lng,\n        ns,\n        fcName,\n        tried,\n        wait,\n        callback\n      });\n      return;\n    }\n    this.readingCalls++;\n    const resolver = (err, data) => {\n      this.readingCalls--;\n      if (this.waitingReads.length > 0) {\n        const next = this.waitingReads.shift();\n        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n      }\n      if (err && data && tried < this.maxRetries) {\n        setTimeout(() => {\n          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n        }, wait);\n        return;\n      }\n      callback(err, data);\n    };\n    const fc = this.backend[fcName].bind(this.backend);\n    if (fc.length === 2) {\n      try {\n        const r = fc(lng, ns);\n        if (r && typeof r.then === 'function') {\n          r.then(data => resolver(null, data)).catch(resolver);\n        } else {\n          resolver(null, r);\n        }\n      } catch (err) {\n        resolver(err);\n      }\n      return;\n    }\n    return fc(lng, ns, resolver);\n  }\n  prepareLoading(languages, namespaces, options = {}, callback) {\n    if (!this.backend) {\n      this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n      return callback && callback();\n    }\n    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n    if (isString(namespaces)) namespaces = [namespaces];\n    const toLoad = this.queueLoad(languages, namespaces, options, callback);\n    if (!toLoad.toLoad.length) {\n      if (!toLoad.pending.length) callback();\n      return null;\n    }\n    toLoad.toLoad.forEach(name => {\n      this.loadOne(name);\n    });\n  }\n  load(languages, namespaces, callback) {\n    this.prepareLoading(languages, namespaces, {}, callback);\n  }\n  reload(languages, namespaces, callback) {\n    this.prepareLoading(languages, namespaces, {\n      reload: true\n    }, callback);\n  }\n  loadOne(name, prefix = '') {\n    const s = name.split('|');\n    const lng = s[0];\n    const ns = s[1];\n    this.read(lng, ns, 'read', undefined, undefined, (err, data) => {\n      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n      this.loaded(name, err, data);\n    });\n  }\n  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {}) {\n    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {\n      this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n      return;\n    }\n    if (key === undefined || key === null || key === '') return;\n    if (this.backend?.create) {\n      const opts = {\n        ...options,\n        isUpdate\n      };\n      const fc = this.backend.create.bind(this.backend);\n      if (fc.length < 6) {\n        try {\n          let r;\n          if (fc.length === 5) {\n            r = fc(languages, namespace, key, fallbackValue, opts);\n          } else {\n            r = fc(languages, namespace, key, fallbackValue);\n          }\n          if (r && typeof r.then === 'function') {\n            r.then(data => clb(null, data)).catch(clb);\n          } else {\n            clb(null, r);\n          }\n        } catch (err) {\n          clb(err);\n        }\n      } else {\n        fc(languages, namespace, key, fallbackValue, clb, opts);\n      }\n    }\n    if (!languages || !languages[0]) return;\n    this.store.addResource(languages[0], namespace, key, fallbackValue);\n  }\n}\n\nconst get = () => ({\n  debug: false,\n  initAsync: true,\n  ns: ['translation'],\n  defaultNS: ['translation'],\n  fallbackLng: ['dev'],\n  fallbackNS: false,\n  supportedLngs: false,\n  nonExplicitSupportedLngs: false,\n  load: 'all',\n  preload: false,\n  simplifyPluralSuffix: true,\n  keySeparator: '.',\n  nsSeparator: ':',\n  pluralSeparator: '_',\n  contextSeparator: '_',\n  partialBundledLanguages: false,\n  saveMissing: false,\n  updateMissing: false,\n  saveMissingTo: 'fallback',\n  saveMissingPlurals: true,\n  missingKeyHandler: false,\n  missingInterpolationHandler: false,\n  postProcess: false,\n  postProcessPassResolved: false,\n  returnNull: false,\n  returnEmptyString: true,\n  returnObjects: false,\n  joinArrays: false,\n  returnedObjectHandler: false,\n  parseMissingKeyHandler: false,\n  appendNamespaceToMissingKey: false,\n  appendNamespaceToCIMode: false,\n  overloadTranslationOptionHandler: args => {\n    let ret = {};\n    if (typeof args[1] === 'object') ret = args[1];\n    if (isString(args[1])) ret.defaultValue = args[1];\n    if (isString(args[2])) ret.tDescription = args[2];\n    if (typeof args[2] === 'object' || typeof args[3] === 'object') {\n      const options = args[3] || args[2];\n      Object.keys(options).forEach(key => {\n        ret[key] = options[key];\n      });\n    }\n    return ret;\n  },\n  interpolation: {\n    escapeValue: true,\n    format: value => value,\n    prefix: '{{',\n    suffix: '}}',\n    formatSeparator: ',',\n    unescapePrefix: '-',\n    nestingPrefix: '$t(',\n    nestingSuffix: ')',\n    nestingOptionsSeparator: ',',\n    maxReplaces: 1000,\n    skipOnVariables: true\n  },\n  cacheInBuiltFormats: true\n});\nconst transformOptions = options => {\n  if (isString(options.ns)) options.ns = [options.ns];\n  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];\n  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];\n  if (options.supportedLngs?.indexOf?.('cimode') < 0) {\n    options.supportedLngs = options.supportedLngs.concat(['cimode']);\n  }\n  if (typeof options.initImmediate === 'boolean') options.initAsync = options.initImmediate;\n  return options;\n};\n\nconst noop = () => {};\nconst bindMemberFunctions = inst => {\n  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n  mems.forEach(mem => {\n    if (typeof inst[mem] === 'function') {\n      inst[mem] = inst[mem].bind(inst);\n    }\n  });\n};\nclass I18n extends EventEmitter {\n  constructor(options = {}, callback) {\n    super();\n    this.options = transformOptions(options);\n    this.services = {};\n    this.logger = baseLogger;\n    this.modules = {\n      external: []\n    };\n    bindMemberFunctions(this);\n    if (callback && !this.isInitialized && !options.isClone) {\n      if (!this.options.initAsync) {\n        this.init(options, callback);\n        return this;\n      }\n      setTimeout(() => {\n        this.init(options, callback);\n      }, 0);\n    }\n  }\n  init(options = {}, callback) {\n    this.isInitializing = true;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (options.defaultNS == null && options.ns) {\n      if (isString(options.ns)) {\n        options.defaultNS = options.ns;\n      } else if (options.ns.indexOf('translation') < 0) {\n        options.defaultNS = options.ns[0];\n      }\n    }\n    const defOpts = get();\n    this.options = {\n      ...defOpts,\n      ...this.options,\n      ...transformOptions(options)\n    };\n    this.options.interpolation = {\n      ...defOpts.interpolation,\n      ...this.options.interpolation\n    };\n    if (options.keySeparator !== undefined) {\n      this.options.userDefinedKeySeparator = options.keySeparator;\n    }\n    if (options.nsSeparator !== undefined) {\n      this.options.userDefinedNsSeparator = options.nsSeparator;\n    }\n    if (typeof this.options.overloadTranslationOptionHandler !== 'function') {\n      this.options.overloadTranslationOptionHandler = defOpts.overloadTranslationOptionHandler;\n    }\n    const createClassOnDemand = ClassOrObject => {\n      if (!ClassOrObject) return null;\n      if (typeof ClassOrObject === 'function') return new ClassOrObject();\n      return ClassOrObject;\n    };\n    if (!this.options.isClone) {\n      if (this.modules.logger) {\n        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n      } else {\n        baseLogger.init(null, this.options);\n      }\n      let formatter;\n      if (this.modules.formatter) {\n        formatter = this.modules.formatter;\n      } else {\n        formatter = Formatter;\n      }\n      const lu = new LanguageUtil(this.options);\n      this.store = new ResourceStore(this.options.resources, this.options);\n      const s = this.services;\n      s.logger = baseLogger;\n      s.resourceStore = this.store;\n      s.languageUtils = lu;\n      s.pluralResolver = new PluralResolver(lu, {\n        prepend: this.options.pluralSeparator,\n        simplifyPluralSuffix: this.options.simplifyPluralSuffix\n      });\n      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;\n      if (usingLegacyFormatFunction) {\n        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);\n      }\n      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n        s.formatter = createClassOnDemand(formatter);\n        if (s.formatter.init) s.formatter.init(s, this.options);\n        this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n      }\n      s.interpolator = new Interpolator(this.options);\n      s.utils = {\n        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n      };\n      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n      s.backendConnector.on('*', (event, ...args) => {\n        this.emit(event, ...args);\n      });\n      if (this.modules.languageDetector) {\n        s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n      }\n      if (this.modules.i18nFormat) {\n        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n        if (s.i18nFormat.init) s.i18nFormat.init(this);\n      }\n      this.translator = new Translator(this.services, this.options);\n      this.translator.on('*', (event, ...args) => {\n        this.emit(event, ...args);\n      });\n      this.modules.external.forEach(m => {\n        if (m.init) m.init(this);\n      });\n    }\n    this.format = this.options.interpolation.format;\n    if (!callback) callback = noop;\n    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n      if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n    }\n    if (!this.services.languageDetector && !this.options.lng) {\n      this.logger.warn('init: no languageDetector is used and no lng is defined');\n    }\n    const storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n    storeApi.forEach(fcName => {\n      this[fcName] = (...args) => this.store[fcName](...args);\n    });\n    const storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n    storeApiChained.forEach(fcName => {\n      this[fcName] = (...args) => {\n        this.store[fcName](...args);\n        return this;\n      };\n    });\n    const deferred = defer();\n    const load = () => {\n      const finish = (err, t) => {\n        this.isInitializing = false;\n        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');\n        this.isInitialized = true;\n        if (!this.options.isClone) this.logger.log('initialized', this.options);\n        this.emit('initialized', this.options);\n        deferred.resolve(t);\n        callback(err, t);\n      };\n      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));\n      this.changeLanguage(this.options.lng, finish);\n    };\n    if (this.options.resources || !this.options.initAsync) {\n      load();\n    } else {\n      setTimeout(load, 0);\n    }\n    return deferred;\n  }\n  loadResources(language, callback = noop) {\n    let usedCallback = callback;\n    const usedLng = isString(language) ? language : this.language;\n    if (typeof language === 'function') usedCallback = language;\n    if (!this.options.resources || this.options.partialBundledLanguages) {\n      if (usedLng?.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n      const toLoad = [];\n      const append = lng => {\n        if (!lng) return;\n        if (lng === 'cimode') return;\n        const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n        lngs.forEach(l => {\n          if (l === 'cimode') return;\n          if (toLoad.indexOf(l) < 0) toLoad.push(l);\n        });\n      };\n      if (!usedLng) {\n        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        fallbacks.forEach(l => append(l));\n      } else {\n        append(usedLng);\n      }\n      this.options.preload?.forEach?.(l => append(l));\n      this.services.backendConnector.load(toLoad, this.options.ns, e => {\n        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n        usedCallback(e);\n      });\n    } else {\n      usedCallback(null);\n    }\n  }\n  reloadResources(lngs, ns, callback) {\n    const deferred = defer();\n    if (typeof lngs === 'function') {\n      callback = lngs;\n      lngs = undefined;\n    }\n    if (typeof ns === 'function') {\n      callback = ns;\n      ns = undefined;\n    }\n    if (!lngs) lngs = this.languages;\n    if (!ns) ns = this.options.ns;\n    if (!callback) callback = noop;\n    this.services.backendConnector.reload(lngs, ns, err => {\n      deferred.resolve();\n      callback(err);\n    });\n    return deferred;\n  }\n  use(module) {\n    if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n    if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n    if (module.type === 'backend') {\n      this.modules.backend = module;\n    }\n    if (module.type === 'logger' || module.log && module.warn && module.error) {\n      this.modules.logger = module;\n    }\n    if (module.type === 'languageDetector') {\n      this.modules.languageDetector = module;\n    }\n    if (module.type === 'i18nFormat') {\n      this.modules.i18nFormat = module;\n    }\n    if (module.type === 'postProcessor') {\n      postProcessor.addPostProcessor(module);\n    }\n    if (module.type === 'formatter') {\n      this.modules.formatter = module;\n    }\n    if (module.type === '3rdParty') {\n      this.modules.external.push(module);\n    }\n    return this;\n  }\n  setResolvedLanguage(l) {\n    if (!l || !this.languages) return;\n    if (['cimode', 'dev'].indexOf(l) > -1) return;\n    for (let li = 0; li < this.languages.length; li++) {\n      const lngInLngs = this.languages[li];\n      if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;\n      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n        this.resolvedLanguage = lngInLngs;\n        break;\n      }\n    }\n    if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {\n      this.resolvedLanguage = l;\n      this.languages.unshift(l);\n    }\n  }\n  changeLanguage(lng, callback) {\n    this.isLanguageChangingTo = lng;\n    const deferred = defer();\n    this.emit('languageChanging', lng);\n    const setLngProps = l => {\n      this.language = l;\n      this.languages = this.services.languageUtils.toResolveHierarchy(l);\n      this.resolvedLanguage = undefined;\n      this.setResolvedLanguage(l);\n    };\n    const done = (err, l) => {\n      if (l) {\n        if (this.isLanguageChangingTo === lng) {\n          setLngProps(l);\n          this.translator.changeLanguage(l);\n          this.isLanguageChangingTo = undefined;\n          this.emit('languageChanged', l);\n          this.logger.log('languageChanged', l);\n        }\n      } else {\n        this.isLanguageChangingTo = undefined;\n      }\n      deferred.resolve((...args) => this.t(...args));\n      if (callback) callback(err, (...args) => this.t(...args));\n    };\n    const setLng = lngs => {\n      if (!lng && !lngs && this.services.languageDetector) lngs = [];\n      const fl = isString(lngs) ? lngs : lngs && lngs[0];\n      const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);\n      if (l) {\n        if (!this.language) {\n          setLngProps(l);\n        }\n        if (!this.translator.language) this.translator.changeLanguage(l);\n        this.services.languageDetector?.cacheUserLanguage?.(l);\n      }\n      this.loadResources(l, err => {\n        done(err, l);\n      });\n    };\n    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n      setLng(this.services.languageDetector.detect());\n    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n      if (this.services.languageDetector.detect.length === 0) {\n        this.services.languageDetector.detect().then(setLng);\n      } else {\n        this.services.languageDetector.detect(setLng);\n      }\n    } else {\n      setLng(lng);\n    }\n    return deferred;\n  }\n  getFixedT(lng, ns, keyPrefix) {\n    const fixedT = (key, opts, ...rest) => {\n      let o;\n      if (typeof opts !== 'object') {\n        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n      } else {\n        o = {\n          ...opts\n        };\n      }\n      o.lng = o.lng || fixedT.lng;\n      o.lngs = o.lngs || fixedT.lngs;\n      o.ns = o.ns || fixedT.ns;\n      if (o.keyPrefix !== '') o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;\n      const keySeparator = this.options.keySeparator || '.';\n      let resultKey;\n      if (o.keyPrefix && Array.isArray(key)) {\n        resultKey = key.map(k => {\n          if (typeof k === 'function') k = keysFromSelector(k, {\n            ...this.options,\n            ...opts\n          });\n          return `${o.keyPrefix}${keySeparator}${k}`;\n        });\n      } else {\n        if (typeof key === 'function') key = keysFromSelector(key, {\n          ...this.options,\n          ...opts\n        });\n        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;\n      }\n      return this.t(resultKey, o);\n    };\n    if (isString(lng)) {\n      fixedT.lng = lng;\n    } else {\n      fixedT.lngs = lng;\n    }\n    fixedT.ns = ns;\n    fixedT.keyPrefix = keyPrefix;\n    return fixedT;\n  }\n  t(...args) {\n    return this.translator?.translate(...args);\n  }\n  exists(...args) {\n    return this.translator?.exists(...args);\n  }\n  setDefaultNamespace(ns) {\n    this.options.defaultNS = ns;\n  }\n  hasLoadedNamespace(ns, options = {}) {\n    if (!this.isInitialized) {\n      this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n      return false;\n    }\n    if (!this.languages || !this.languages.length) {\n      this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n      return false;\n    }\n    const lng = options.lng || this.resolvedLanguage || this.languages[0];\n    const fallbackLng = this.options ? this.options.fallbackLng : false;\n    const lastLng = this.languages[this.languages.length - 1];\n    if (lng.toLowerCase() === 'cimode') return true;\n    const loadNotPending = (l, n) => {\n      const loadState = this.services.backendConnector.state[`${l}|${n}`];\n      return loadState === -1 || loadState === 0 || loadState === 2;\n    };\n    if (options.precheck) {\n      const preResult = options.precheck(this, loadNotPending);\n      if (preResult !== undefined) return preResult;\n    }\n    if (this.hasResourceBundle(lng, ns)) return true;\n    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n    return false;\n  }\n  loadNamespaces(ns, callback) {\n    const deferred = defer();\n    if (!this.options.ns) {\n      if (callback) callback();\n      return Promise.resolve();\n    }\n    if (isString(ns)) ns = [ns];\n    ns.forEach(n => {\n      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n    });\n    this.loadResources(err => {\n      deferred.resolve();\n      if (callback) callback(err);\n    });\n    return deferred;\n  }\n  loadLanguages(lngs, callback) {\n    const deferred = defer();\n    if (isString(lngs)) lngs = [lngs];\n    const preloaded = this.options.preload || [];\n    const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n    if (!newLngs.length) {\n      if (callback) callback();\n      return Promise.resolve();\n    }\n    this.options.preload = preloaded.concat(newLngs);\n    this.loadResources(err => {\n      deferred.resolve();\n      if (callback) callback(err);\n    });\n    return deferred;\n  }\n  dir(lng) {\n    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);\n    if (!lng) return 'rtl';\n    try {\n      const l = new Intl.Locale(lng);\n      if (l && l.getTextInfo) {\n        const ti = l.getTextInfo();\n        if (ti && ti.direction) return ti.direction;\n      }\n    } catch (e) {}\n    const rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];\n    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());\n    if (lng.toLowerCase().indexOf('-latn') > 1) return 'ltr';\n    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n  }\n  static createInstance(options = {}, callback) {\n    const instance = new I18n(options, callback);\n    instance.createInstance = I18n.createInstance;\n    return instance;\n  }\n  cloneInstance(options = {}, callback = noop) {\n    const forkResourceStore = options.forkResourceStore;\n    if (forkResourceStore) delete options.forkResourceStore;\n    const mergedOptions = {\n      ...this.options,\n      ...options,\n      ...{\n        isClone: true\n      }\n    };\n    const clone = new I18n(mergedOptions);\n    if (options.debug !== undefined || options.prefix !== undefined) {\n      clone.logger = clone.logger.clone(options);\n    }\n    const membersToCopy = ['store', 'services', 'language'];\n    membersToCopy.forEach(m => {\n      clone[m] = this[m];\n    });\n    clone.services = {\n      ...this.services\n    };\n    clone.services.utils = {\n      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n    };\n    if (forkResourceStore) {\n      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {\n        prev[l] = {\n          ...this.store.data[l]\n        };\n        prev[l] = Object.keys(prev[l]).reduce((acc, n) => {\n          acc[n] = {\n            ...prev[l][n]\n          };\n          return acc;\n        }, prev[l]);\n        return prev;\n      }, {});\n      clone.store = new ResourceStore(clonedData, mergedOptions);\n      clone.services.resourceStore = clone.store;\n    }\n    if (options.interpolation) {\n      const defOpts = get();\n      const mergedInterpolation = {\n        ...defOpts.interpolation,\n        ...this.options.interpolation,\n        ...options.interpolation\n      };\n      const mergedForInterpolator = {\n        ...mergedOptions,\n        interpolation: mergedInterpolation\n      };\n      clone.services.interpolator = new Interpolator(mergedForInterpolator);\n    }\n    clone.translator = new Translator(clone.services, mergedOptions);\n    clone.translator.on('*', (event, ...args) => {\n      clone.emit(event, ...args);\n    });\n    clone.init(mergedOptions, callback);\n    clone.translator.options = mergedOptions;\n    clone.translator.backendConnector.services.utils = {\n      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n    };\n    return clone;\n  }\n  toJSON() {\n    return {\n      options: this.options,\n      store: this.store,\n      language: this.language,\n      languages: this.languages,\n      resolvedLanguage: this.resolvedLanguage\n    };\n  }\n}\nconst instance = I18n.createInstance();\n\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\nexport { changeLanguage, createInstance, instance as default, dir, exists, getFixedT, hasLoadedNamespace, init, keysFromSelector as keyFromSelector, loadLanguages, loadNamespaces, loadResources, reloadResources, setDefaultNamespace, t, use };\n","const {\n  slice,\n  forEach\n} = [];\nfunction defaults(obj) {\n  forEach.call(slice.call(arguments, 1), source => {\n    if (source) {\n      for (const prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\nfunction hasXSS(input) {\n  if (typeof input !== 'string') return false;\n\n  // Common XSS attack patterns\n  const xssPatterns = [/<\\s*script.*?>/i, /<\\s*\\/\\s*script\\s*>/i, /<\\s*img.*?on\\w+\\s*=/i, /<\\s*\\w+\\s*on\\w+\\s*=.*?>/i, /javascript\\s*:/i, /vbscript\\s*:/i, /expression\\s*\\(/i, /eval\\s*\\(/i, /alert\\s*\\(/i, /document\\.cookie/i, /document\\.write\\s*\\(/i, /window\\.location/i, /innerHTML/i];\n  return xssPatterns.some(pattern => pattern.test(input));\n}\n\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nconst serializeCookie = function (name, val) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    path: '/'\n  };\n  const opt = options;\n  const value = encodeURIComponent(val);\n  let str = `${name}=${value}`;\n  if (opt.maxAge > 0) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += `; Max-Age=${Math.floor(maxAge)}`;\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n    str += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n    str += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n    str += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n  if (opt.partitioned) str += '; Partitioned';\n  return str;\n};\nconst cookie = {\n  create(name, value, minutes, domain) {\n    let cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, value, cookieOptions);\n  },\n  read(name) {\n    const nameEQ = `${name}=`;\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  },\n  remove(name, domain) {\n    this.create(name, '', -1, domain);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  // Deconstruct the options object and extract the lookupCookie property\n  lookup(_ref) {\n    let {\n      lookupCookie\n    } = _ref;\n    if (lookupCookie && typeof document !== 'undefined') {\n      return cookie.read(lookupCookie) || undefined;\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupCookie,\n      cookieMinutes,\n      cookieDomain,\n      cookieOptions\n    } = _ref2;\n    if (lookupCookie && typeof document !== 'undefined') {\n      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  // Deconstruct the options object and extract the lookupQuerystring property\n  lookup(_ref) {\n    let {\n      lookupQuerystring\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      let {\n        search\n      } = window.location;\n      if (!window.location.search && window.location.hash?.indexOf('?') > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n      const query = search.substring(1);\n      const params = query.split('&');\n      for (let i = 0; i < params.length; i++) {\n        const pos = params[i].indexOf('=');\n        if (pos > 0) {\n          const key = params[i].substring(0, pos);\n          if (key === lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n    return found;\n  }\n};\n\nvar hash = {\n  name: 'hash',\n  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property\n  lookup(_ref) {\n    let {\n      lookupHash,\n      lookupFromHashIndex\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      const {\n        hash\n      } = window.location;\n      if (hash && hash.length > 2) {\n        const query = hash.substring(1);\n        if (lookupHash) {\n          const params = query.split('&');\n          for (let i = 0; i < params.length; i++) {\n            const pos = params[i].indexOf('=');\n            if (pos > 0) {\n              const key = params[i].substring(0, pos);\n              if (key === lookupHash) {\n                found = params[i].substring(pos + 1);\n              }\n            }\n          }\n        }\n        if (found) return found;\n        if (!found && lookupFromHashIndex > -1) {\n          const language = hash.match(/\\/([a-zA-Z-]*)/g);\n          if (!Array.isArray(language)) return undefined;\n          const index = typeof lookupFromHashIndex === 'number' ? lookupFromHashIndex : 0;\n          return language[index]?.replace('/', '');\n        }\n      }\n    }\n    return found;\n  }\n};\n\nlet hasLocalStorageSupport = null;\nconst localStorageAvailable = () => {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n  try {\n    hasLocalStorageSupport = typeof window !== 'undefined' && window.localStorage !== null;\n    if (!hasLocalStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n  return hasLocalStorageSupport;\n};\nvar localStorage = {\n  name: 'localStorage',\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  lookup(_ref) {\n    let {\n      lookupLocalStorage\n    } = _ref;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      return window.localStorage.getItem(lookupLocalStorage) || undefined; // Undefined ensures type consistency with the previous version of this function\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupLocalStorage\n    } = _ref2;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(lookupLocalStorage, lng);\n    }\n  }\n};\n\nlet hasSessionStorageSupport = null;\nconst sessionStorageAvailable = () => {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n  try {\n    hasSessionStorageSupport = typeof window !== 'undefined' && window.sessionStorage !== null;\n    if (!hasSessionStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n  return hasSessionStorageSupport;\n};\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup(_ref) {\n    let {\n      lookupSessionStorage\n    } = _ref;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      return window.sessionStorage.getItem(lookupSessionStorage) || undefined;\n    }\n    return undefined;\n  },\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupSessionStorage\n    } = _ref2;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup(options) {\n    const found = [];\n    if (typeof navigator !== 'undefined') {\n      const {\n        languages,\n        userLanguage,\n        language\n      } = navigator;\n      if (languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (let i = 0; i < languages.length; i++) {\n          found.push(languages[i]);\n        }\n      }\n      if (userLanguage) {\n        found.push(userLanguage);\n      }\n      if (language) {\n        found.push(language);\n      }\n    }\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  // Deconstruct the options object and extract the htmlTag property\n  lookup(_ref) {\n    let {\n      htmlTag\n    } = _ref;\n    let found;\n    const internalHtmlTag = htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === 'function') {\n      found = internalHtmlTag.getAttribute('lang');\n    }\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  // Deconstruct the options object and extract the lookupFromPathIndex property\n  lookup(_ref) {\n    let {\n      lookupFromPathIndex\n    } = _ref;\n    if (typeof window === 'undefined') return undefined;\n    const language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n    if (!Array.isArray(language)) return undefined;\n    const index = typeof lookupFromPathIndex === 'number' ? lookupFromPathIndex : 0;\n    return language[index]?.replace('/', '');\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup(_ref) {\n    let {\n      lookupFromSubdomainIndex\n    } = _ref;\n    // If given get the subdomain index else 1\n    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === 'number' ? lookupFromSubdomainIndex + 1 : 1;\n    // get all matches if window.location. is existing\n    // first item of match is the match itself and the second is the first group match which should be the first subdomain match\n    // is the hostname no public domain get the or option of localhost\n    const language = typeof window !== 'undefined' && window.location?.hostname?.match(/^(\\w{2,5})\\.(([a-z0-9-]{1,63}\\.[a-z]{2,6})|localhost)/i);\n\n    // if there is no match (null) return undefined\n    if (!language) return undefined;\n    // return the given group match\n    return language[internalLookupFromSubdomainIndex];\n  }\n};\n\n// some environments, throws when accessing document.cookie\nlet canCookies = false;\ntry {\n  // eslint-disable-next-line no-unused-expressions\n  document.cookie;\n  canCookies = true;\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nconst order = ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'];\nif (!canCookies) order.splice(1, 1);\nconst getDefaults = () => ({\n  order,\n  lookupQuerystring: 'lng',\n  lookupCookie: 'i18next',\n  lookupLocalStorage: 'i18nextLng',\n  lookupSessionStorage: 'i18nextLng',\n  // cache user language\n  caches: ['localStorage'],\n  excludeCacheFor: ['cimode'],\n  // cookieMinutes: 10,\n  // cookieDomain: 'myDomain'\n\n  convertDetectedLanguage: l => l\n});\nclass Browser {\n  constructor(services) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n  init() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      languageUtils: {}\n    };\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.services = services;\n    this.options = defaults(options, this.options || {}, getDefaults());\n    if (typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1) {\n      this.options.convertDetectedLanguage = l => l.replace('-', '_');\n    }\n\n    // backwards compatibility\n    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n    this.i18nOptions = i18nOptions;\n    this.addDetector(cookie$1);\n    this.addDetector(querystring);\n    this.addDetector(localStorage);\n    this.addDetector(sessionStorage);\n    this.addDetector(navigator$1);\n    this.addDetector(htmlTag);\n    this.addDetector(path);\n    this.addDetector(subdomain);\n    this.addDetector(hash);\n  }\n  addDetector(detector) {\n    this.detectors[detector.name] = detector;\n    return this;\n  }\n  detect() {\n    let detectionOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.order;\n    let detected = [];\n    detectionOrder.forEach(detectorName => {\n      if (this.detectors[detectorName]) {\n        let lookup = this.detectors[detectorName].lookup(this.options);\n        if (lookup && typeof lookup === 'string') lookup = [lookup];\n        if (lookup) detected = detected.concat(lookup);\n      }\n    });\n    detected = detected.filter(d => d !== undefined && d !== null && !hasXSS(d)).map(d => this.options.convertDetectedLanguage(d));\n    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n    return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n  }\n  cacheUserLanguage(lng) {\n    let caches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.caches;\n    if (!caches) return;\n    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n    caches.forEach(cacheName => {\n      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);\n    });\n  }\n}\nBrowser.type = 'languageDetector';\n\nexport { Browser as default };\n","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\nexport function defaults(obj) {\n  each.call(slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\nexport function hasXMLHttpRequest() {\n  return typeof XMLHttpRequest === 'function' || (typeof XMLHttpRequest === \"undefined\" ? \"undefined\" : _typeof(XMLHttpRequest)) === 'object';\n}\nfunction isPromise(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\nexport function makePromise(maybePromise) {\n  if (isPromise(maybePromise)) {\n    return maybePromise;\n  }\n  return Promise.resolve(maybePromise);\n}","function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nimport { hasXMLHttpRequest } from './utils.js';\nvar fetchApi = typeof fetch === 'function' ? fetch : undefined;\nif (typeof global !== 'undefined' && global.fetch) {\n  fetchApi = global.fetch;\n} else if (typeof window !== 'undefined' && window.fetch) {\n  fetchApi = window.fetch;\n}\nvar XmlHttpRequestApi;\nif (hasXMLHttpRequest()) {\n  if (typeof global !== 'undefined' && global.XMLHttpRequest) {\n    XmlHttpRequestApi = global.XMLHttpRequest;\n  } else if (typeof window !== 'undefined' && window.XMLHttpRequest) {\n    XmlHttpRequestApi = window.XMLHttpRequest;\n  }\n}\nvar ActiveXObjectApi;\nif (typeof ActiveXObject === 'function') {\n  if (typeof global !== 'undefined' && global.ActiveXObject) {\n    ActiveXObjectApi = global.ActiveXObject;\n  } else if (typeof window !== 'undefined' && window.ActiveXObject) {\n    ActiveXObjectApi = window.ActiveXObject;\n  }\n}\nif (typeof fetchApi !== 'function') fetchApi = undefined;\nif (!fetchApi && !XmlHttpRequestApi && !ActiveXObjectApi) {\n  try {\n    import('cross-fetch').then(function (mod) {\n      fetchApi = mod.default;\n    }).catch(function () {});\n  } catch (e) {}\n}\nvar addQueryString = function addQueryString(url, params) {\n  if (params && _typeof(params) === 'object') {\n    var queryString = '';\n    for (var paramName in params) {\n      queryString += '&' + encodeURIComponent(paramName) + '=' + encodeURIComponent(params[paramName]);\n    }\n    if (!queryString) return url;\n    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);\n  }\n  return url;\n};\nvar fetchIt = function fetchIt(url, fetchOptions, callback, altFetch) {\n  var resolver = function resolver(response) {\n    if (!response.ok) return callback(response.statusText || 'Error', {\n      status: response.status\n    });\n    response.text().then(function (data) {\n      callback(null, {\n        status: response.status,\n        data: data\n      });\n    }).catch(callback);\n  };\n  if (altFetch) {\n    var altResponse = altFetch(url, fetchOptions);\n    if (altResponse instanceof Promise) {\n      altResponse.then(resolver).catch(callback);\n      return;\n    }\n  }\n  if (typeof fetch === 'function') {\n    fetch(url, fetchOptions).then(resolver).catch(callback);\n  } else {\n    fetchApi(url, fetchOptions).then(resolver).catch(callback);\n  }\n};\nvar omitFetchOptions = false;\nvar requestWithFetch = function requestWithFetch(options, url, payload, callback) {\n  if (options.queryStringParams) {\n    url = addQueryString(url, options.queryStringParams);\n  }\n  var headers = _objectSpread({}, typeof options.customHeaders === 'function' ? options.customHeaders() : options.customHeaders);\n  if (typeof window === 'undefined' && typeof global !== 'undefined' && typeof global.process !== 'undefined' && global.process.versions && global.process.versions.node) {\n    headers['User-Agent'] = \"i18next-http-backend (node/\".concat(global.process.version, \"; \").concat(global.process.platform, \" \").concat(global.process.arch, \")\");\n  }\n  if (payload) headers['Content-Type'] = 'application/json';\n  var reqOptions = typeof options.requestOptions === 'function' ? options.requestOptions(payload) : options.requestOptions;\n  var fetchOptions = _objectSpread({\n    method: payload ? 'POST' : 'GET',\n    body: payload ? options.stringify(payload) : undefined,\n    headers: headers\n  }, omitFetchOptions ? {} : reqOptions);\n  var altFetch = typeof options.alternateFetch === 'function' && options.alternateFetch.length >= 1 ? options.alternateFetch : undefined;\n  try {\n    fetchIt(url, fetchOptions, callback, altFetch);\n  } catch (e) {\n    if (!reqOptions || Object.keys(reqOptions).length === 0 || !e.message || e.message.indexOf('not implemented') < 0) {\n      return callback(e);\n    }\n    try {\n      Object.keys(reqOptions).forEach(function (opt) {\n        delete fetchOptions[opt];\n      });\n      fetchIt(url, fetchOptions, callback, altFetch);\n      omitFetchOptions = true;\n    } catch (err) {\n      callback(err);\n    }\n  }\n};\nvar requestWithXmlHttpRequest = function requestWithXmlHttpRequest(options, url, payload, callback) {\n  if (payload && _typeof(payload) === 'object') {\n    payload = addQueryString('', payload).slice(1);\n  }\n  if (options.queryStringParams) {\n    url = addQueryString(url, options.queryStringParams);\n  }\n  try {\n    var x = XmlHttpRequestApi ? new XmlHttpRequestApi() : new ActiveXObjectApi('MSXML2.XMLHTTP.3.0');\n    x.open(payload ? 'POST' : 'GET', url, 1);\n    if (!options.crossDomain) {\n      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    }\n    x.withCredentials = !!options.withCredentials;\n    if (payload) {\n      x.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    }\n    if (x.overrideMimeType) {\n      x.overrideMimeType('application/json');\n    }\n    var h = options.customHeaders;\n    h = typeof h === 'function' ? h() : h;\n    if (h) {\n      for (var i in h) {\n        x.setRequestHeader(i, h[i]);\n      }\n    }\n    x.onreadystatechange = function () {\n      x.readyState > 3 && callback(x.status >= 400 ? x.statusText : null, {\n        status: x.status,\n        data: x.responseText\n      });\n    };\n    x.send(payload);\n  } catch (e) {\n    console && console.log(e);\n  }\n};\nvar request = function request(options, url, payload, callback) {\n  if (typeof payload === 'function') {\n    callback = payload;\n    payload = undefined;\n  }\n  callback = callback || function () {};\n  if (fetchApi && url.indexOf('file:') !== 0) {\n    return requestWithFetch(options, url, payload, callback);\n  }\n  if (hasXMLHttpRequest() || typeof ActiveXObject === 'function') {\n    return requestWithXmlHttpRequest(options, url, payload, callback);\n  }\n  callback(new Error('No fetch and no xhr implementation found!'));\n};\nexport default request;","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { makePromise } from './utils.js';\nimport request from './request.js';\nvar getDefaults = function getDefaults() {\n  return {\n    loadPath: '/locales/{{lng}}/{{ns}}.json',\n    addPath: '/locales/add/{{lng}}/{{ns}}',\n    parse: function parse(data) {\n      return JSON.parse(data);\n    },\n    stringify: JSON.stringify,\n    parsePayload: function parsePayload(namespace, key, fallbackValue) {\n      return _defineProperty({}, key, fallbackValue || '');\n    },\n    parseLoadPayload: function parseLoadPayload(languages, namespaces) {\n      return undefined;\n    },\n    request: request,\n    reloadInterval: typeof window !== 'undefined' ? false : 60 * 60 * 1000,\n    customHeaders: {},\n    queryStringParams: {},\n    crossDomain: false,\n    withCredentials: false,\n    overrideMimeType: false,\n    requestOptions: {\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'default'\n    }\n  };\n};\nvar Backend = function () {\n  function Backend(services) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Backend);\n    this.services = services;\n    this.options = options;\n    this.allOptions = allOptions;\n    this.type = 'backend';\n    this.init(services, options, allOptions);\n  }\n  return _createClass(Backend, [{\n    key: \"init\",\n    value: function init(services) {\n      var _this = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.services = services;\n      this.options = _objectSpread(_objectSpread(_objectSpread({}, getDefaults()), this.options || {}), options);\n      this.allOptions = allOptions;\n      if (this.services && this.options.reloadInterval) {\n        var timer = setInterval(function () {\n          return _this.reload();\n        }, this.options.reloadInterval);\n        if (_typeof(timer) === 'object' && typeof timer.unref === 'function') timer.unref();\n      }\n    }\n  }, {\n    key: \"readMulti\",\n    value: function readMulti(languages, namespaces, callback) {\n      this._readAny(languages, languages, namespaces, namespaces, callback);\n    }\n  }, {\n    key: \"read\",\n    value: function read(language, namespace, callback) {\n      this._readAny([language], language, [namespace], namespace, callback);\n    }\n  }, {\n    key: \"_readAny\",\n    value: function _readAny(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {\n      var _this2 = this;\n      var loadPath = this.options.loadPath;\n      if (typeof this.options.loadPath === 'function') {\n        loadPath = this.options.loadPath(languages, namespaces);\n      }\n      loadPath = makePromise(loadPath);\n      loadPath.then(function (resolvedLoadPath) {\n        if (!resolvedLoadPath) return callback(null, {});\n        var url = _this2.services.interpolator.interpolate(resolvedLoadPath, {\n          lng: languages.join('+'),\n          ns: namespaces.join('+')\n        });\n        _this2.loadUrl(url, callback, loadUrlLanguages, loadUrlNamespaces);\n      });\n    }\n  }, {\n    key: \"loadUrl\",\n    value: function loadUrl(url, callback, languages, namespaces) {\n      var _this3 = this;\n      var lng = typeof languages === 'string' ? [languages] : languages;\n      var ns = typeof namespaces === 'string' ? [namespaces] : namespaces;\n      var payload = this.options.parseLoadPayload(lng, ns);\n      this.options.request(this.options, url, payload, function (err, res) {\n        if (res && (res.status >= 500 && res.status < 600 || !res.status)) return callback('failed loading ' + url + '; status code: ' + res.status, true);\n        if (res && res.status >= 400 && res.status < 500) return callback('failed loading ' + url + '; status code: ' + res.status, false);\n        if (!res && err && err.message) {\n          var errorMessage = err.message.toLowerCase();\n          var isNetworkError = ['failed', 'fetch', 'network', 'load'].find(function (term) {\n            return errorMessage.indexOf(term) > -1;\n          });\n          if (isNetworkError) {\n            return callback('failed loading ' + url + ': ' + err.message, true);\n          }\n        }\n        if (err) return callback(err, false);\n        var ret, parseErr;\n        try {\n          if (typeof res.data === 'string') {\n            ret = _this3.options.parse(res.data, languages, namespaces);\n          } else {\n            ret = res.data;\n          }\n        } catch (e) {\n          parseErr = 'failed parsing ' + url + ' to json';\n        }\n        if (parseErr) return callback(parseErr, false);\n        callback(null, ret);\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create(languages, namespace, key, fallbackValue, callback) {\n      var _this4 = this;\n      if (!this.options.addPath) return;\n      if (typeof languages === 'string') languages = [languages];\n      var payload = this.options.parsePayload(namespace, key, fallbackValue);\n      var finished = 0;\n      var dataArray = [];\n      var resArray = [];\n      languages.forEach(function (lng) {\n        var addPath = _this4.options.addPath;\n        if (typeof _this4.options.addPath === 'function') {\n          addPath = _this4.options.addPath(lng, namespace);\n        }\n        var url = _this4.services.interpolator.interpolate(addPath, {\n          lng: lng,\n          ns: namespace\n        });\n        _this4.options.request(_this4.options, url, payload, function (data, res) {\n          finished += 1;\n          dataArray.push(data);\n          resArray.push(res);\n          if (finished === languages.length) {\n            if (typeof callback === 'function') callback(dataArray, resArray);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      var _this5 = this;\n      var _this$services = this.services,\n        backendConnector = _this$services.backendConnector,\n        languageUtils = _this$services.languageUtils,\n        logger = _this$services.logger;\n      var currentLanguage = backendConnector.language;\n      if (currentLanguage && currentLanguage.toLowerCase() === 'cimode') return;\n      var toLoad = [];\n      var append = function append(lng) {\n        var lngs = languageUtils.toResolveHierarchy(lng);\n        lngs.forEach(function (l) {\n          if (toLoad.indexOf(l) < 0) toLoad.push(l);\n        });\n      };\n      append(currentLanguage);\n      if (this.allOptions.preload) this.allOptions.preload.forEach(function (l) {\n        return append(l);\n      });\n      toLoad.forEach(function (lng) {\n        _this5.allOptions.ns.forEach(function (ns) {\n          backendConnector.read(lng, ns, 'read', null, null, function (err, data) {\n            if (err) logger.warn(\"loading namespace \".concat(ns, \" for language \").concat(lng, \" failed\"), err);\n            if (!err && data) logger.log(\"loaded namespace \".concat(ns, \" for language \").concat(lng), data);\n            backendConnector.loaded(\"\".concat(lng, \"|\").concat(ns), err, data);\n          });\n        });\n      });\n    }\n  }]);\n}();\nBackend.type = 'backend';\nexport default Backend;","import i18n from 'i18next';\nimport { configureI18N } from '../../configureI18N';\n/**\n * Custom Chart.js plugin for labels translation\n */\nexport const translatedLabelsPlugin = {\n    id: 'translatedLabels',\n    async afterInit(chart) {\n        configureI18N();\n        i18n.on(\"initialized\", () => {\n            translateLabels(i18n, chart);\n            const languages = ['en', 'de', 'pl'];\n            // Add event listener for language change\n            document.addEventListener('keydown', (event) => {\n                if (event.key === 'L') {\n                    const currentLanguage = i18n.language;\n                    const index = languages.indexOf(currentLanguage);\n                    const nextIndex = (index + 1) % languages.length;\n                    const nextLanguage = languages[nextIndex];\n                    i18n.changeLanguage(nextLanguage, (err) => {\n                        if (err) {\n                            console.error(`Failed to load language ${nextLanguage}:`, err);\n                            return;\n                        }\n                        translateLabels(i18n, chart);\n                    });\n                }\n            });\n        });\n    }\n};\nconst translateLabels = (i18n, chart) => {\n    // translate terms for datasets\n    chart.data.datasets.forEach((dataset) => {\n        const isParsingAnObject = typeof dataset.parsing === 'object';\n        // Uses a map for dataset parsing to store our translationKey (see also chart dataset configuration)\n        const key = isParsingAnObject ? dataset.parsing.translationKey : null;\n        const translatedTerm = key ? i18n.t(key) : '';\n        dataset.label = translatedTerm;\n    });\n    // translate over multi-labels\n    const translatedMultiLabels = chart.data.labels.map((labels) => {\n        return labels.map(label => ({ key: label.key, translation: i18n.t(label.key) }));\n    });\n    chart.data.labels = translatedMultiLabels;\n    chart.update();\n};\n","import i18n from 'i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport HttpBackend from 'i18next-http-backend';\nexport function configureI18N() {\n    i18n\n        .use(HttpBackend)\n        .use(LanguageDetector)\n        .init({\n        debug: true,\n        fallbackLng: \"en\",\n        backend: {\n            loadPath: \"/i18n/{{lng}}.json\"\n        }\n    });\n}\n","import { Chart, DoughnutController, ArcElement, Tooltip, Legend, } from 'chart.js';\nimport { seasons, months } from './chartData';\nimport { rotatedLabelsPlugin } from './rotatedLabelsPlugin/rotatedLabelsPlugin';\nimport { translatedLabelsPlugin } from './translatedLabelsPlugin/translatedLabelsPlugin';\n// Register Chart.js components\nChart.register(DoughnutController, ArcElement, Tooltip, Legend);\nexport function initializeChart(canvasElement) {\n    // Extract data directly from flat arrays\n    const seasonLabels = seasons.map(s => ({ key: s.label, translation: s.label }));\n    const seasonValues = seasons.map(s => s.value);\n    const seasonColors = seasons.map(s => s.color);\n    const monthLabels = months.map(m => ({ key: m.label, translation: m.label }));\n    const monthValues = months.map(m => m.value);\n    const monthColors = months.map(m => m.color);\n    const config = {\n        type: 'doughnut',\n        data: {\n            // array of arrays: we need multilabels here to have array for each series of data\n            labels: [monthLabels, seasonLabels],\n            datasets: [\n                // ordered from outermost to innermost\n                {\n                    parsing: { translationKey: 'months.term' },\n                    label: 'months.term',\n                    data: monthValues,\n                    backgroundColor: monthColors,\n                    borderWidth: 2,\n                    borderColor: '#fff',\n                    weight: 5.0,\n                },\n                {\n                    parsing: { translationKey: 'seasons.term' },\n                    label: 'seasons.term',\n                    data: seasonValues,\n                    backgroundColor: seasonColors,\n                    borderWidth: 2,\n                    borderColor: '#fff',\n                    weight: 3.0,\n                },\n            ],\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: true,\n            // The portion of the chart that is cut out of the middle.\n            cutout: '35%',\n            plugins: {\n                legend: {\n                    display: false, // Hide legend since we have labels on chart\n                },\n                tooltip: {\n                    enabled: true,\n                    callbacks: {\n                        // by default the title is taken from labels, but we have multilabels and need to overwrite default behaviour\n                        title: function (items) {\n                            const context = items[0];\n                            return context.dataset.label || '';\n                        },\n                        label: function (context) {\n                            const multiLabels = context.chart.data.labels;\n                            const seriesLabels = multiLabels ? multiLabels[context.datasetIndex] : [];\n                            const label = seriesLabels[context.dataIndex]?.translation || '';\n                            const value = context.parsed || 0;\n                            return `${label}: ${value} days`;\n                        },\n                    },\n                },\n            },\n            layout: {\n                padding: 20,\n            },\n        },\n        plugins: [\n            rotatedLabelsPlugin,\n            translatedLabelsPlugin,\n        ],\n    };\n    return new Chart(canvasElement, config);\n}\n","import './styles.css';\nimport { initializeChart } from './chart/chart';\nconst rootElement = document.getElementById('root');\nif (rootElement) {\n    console.info('Root element found:', rootElement);\n}\n// Initialize the chart\nconst canvasElement = document.getElementById('myChart');\nif (canvasElement) {\n    const chart = initializeChart(canvasElement);\n    console.info('Chart initialized');\n    let rotationDegrees = 0;\n    // Add event listener for chart rotation\n    document.addEventListener('keydown', (event) => {\n        if (event.key === '[') {\n            rotationDegrees -= 6;\n            chart.options.rotation = rotationDegrees;\n            chart.update();\n        }\n        else if (event.key === ']') {\n            rotationDegrees += 6;\n            chart.options.rotation = rotationDegrees;\n            chart.update();\n        }\n    });\n}\n"],"names":["leafPrototypes","getProto","inProgress","dataWebpackPrefix","module","exports","styleElement","nonce","setAttribute","stylesInDOM","getIndexByIdentifier","identifier","result","i","length","modulesToDom","list","options","idCountMap","identifiers","item","id","base","count","concat","indexByIdentifier","obj","css","media","sourceMap","supports","layer","references","updater","addElementStyle","byIndex","splice","push","api","domAPI","update","newObj","remove","lastIdentifiers","newList","index","newLastIdentifiers","_i","_index","styleSheet","cssText","firstChild","removeChild","appendChild","document","createTextNode","cssWithMappingToString","toString","this","map","content","needLayer","join","modules","dedupe","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","___CSS_LOADER_EXPORT___","element","createElement","setAttributes","attributes","insert","memo","style","target","styleTarget","querySelector","window","HTMLIFrameElement","contentDocument","head","e","getTarget","Error","insertStyleElement","styleTagTransform","apply","parentNode","removeStyleElement","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","n","getter","__esModule","d","a","Object","getPrototypeOf","t","value","mode","then","ns","create","r","def","current","indexOf","getOwnPropertyNames","forEach","key","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","keys","reduce","promises","u","g","globalThis","Function","prop","prototype","hasOwnProperty","call","l","url","done","script","needAttach","scripts","getElementsByTagName","s","getAttribute","charset","nc","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","timeout","doneFns","fn","setTimeout","bind","type","Symbol","toStringTag","scriptUrl","importScripts","location","currentScript","tagName","toUpperCase","test","replace","p","installedChunks","j","installedChunkData","promise","resolve","reject","error","errorType","realSrc","message","name","request","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","some","chunkLoadingGlobal","self","round","v","locals","lim","h","Math","max","min","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","b","c","hex","h1","h2","eq","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","w","rgb","rgb2hsl","hueValue","calln","Array","isArray","hsl2rgb","hue","x","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","RGB_RE","to","pow","from","modHSL","ratio","tmp","clone","proto","assign","fromObject","input","functionParse","str","charAt","exec","rgbParse","p1","p2","hwb2rgb","hsv2rgb","hueParse","Color","constructor","ret","len","unpacked","tkeys","ok","nk","parseInt","unpack","transparent","toLowerCase","nameParse","_rgb","_valid","valid","rgbString","hexString","isShort","alpha","hslString","mix","color","weight","c1","c2","w2","w1","interpolate","rgb1","rgb2","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","noop","uid","isNullOrUndef","slice","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toDimension","dimension","endsWith","parseFloat","callback","args","thisArg","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","source","klen","isValidKey","_merger","tval","sval","merge","sources","merger","mergeIf","_mergerIf","keyResolvers","y","resolveObjectKey","resolver","parts","split","part","_splitKey","_getKeyResolver","_capitalize","defined","isFunction","setsEqual","size","has","PI","TAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","isNumber","toPrimitive","isNonPrimitive","isNaN","toRadians","degrees","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","sqrt","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_isBetween","epsilon","_lookup","table","cmp","mid","hi","lo","_lookupByKey","last","ti","_rlookupByKey","arrayEvents","unlistenArrayEvents","array","listener","stub","_chartjs","listeners","requestAnimFrame","requestAnimationFrame","throttled","argsToUse","ticking","_toLeftRightCenter","align","_alignStartEnd","atEdge","elasticIn","sin","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","numbers","colors","intlCache","Map","formatNumber","num","locale","cacheKey","formatter","Intl","NumberFormat","set","getNumberFormat","format","formatters","values","numeric","tickValue","ticks","chart","notation","delta","maxTick","abs","floor","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","includes","Ticks","overrides","descriptors","getScope$1","node","root","scope","Defaults","_descriptors","_appliers","animation","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","lineHeight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","local","appliers","defaults","_scriptable","startsWith","_indexable","_fallback","delay","duration","easing","loop","properties","active","resize","show","animations","visible","hide","autoPadding","padding","top","right","bottom","left","display","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","_measureText","gc","longest","string","textWidth","measureText","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","save","resetTransform","clearRect","height","restore","drawPoint","drawPointLegend","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","_isPointInArea","point","area","margin","clipArea","unclipArea","decorateText","line","opts","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","strokeStyle","fillStyle","decorationWidth","drawBackdrop","oldColor","fillRect","renderText","lines","strokeWidth","strokeColor","translation","textAlign","textBaseline","setRenderOpts","backdrop","strokeText","maxWidth","fillText","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","match","numberOrZero","_readValueToProps","props","objProps","read","toTRBLCorners","toPadding","toTRBL","toFont","fallback","console","warn","toFontString","inputs","info","cacheable","createContext","parentContext","_createResolver","scopes","prefixes","rootScopes","finalRootScopes","_resolve","cache","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","Set","setContext","receiver","isScriptable","getValue","add","delete","_resolveScriptable","isIndexable","arr","filter","_resolveArray","_resolveWithContext","allKeys","configurable","scriptable","indexable","_allKeys","resolveFallback","getScope","parent","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_isDomSupported","_getParentNode","domNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","EPSILON","getComputedStyle","ownerDocument","defaultView","positions","getPositionedStyle","styles","suffix","pos","getRelativePosition","borderBox","boxSizing","paddings","borders","box","touches","offsetX","offsetY","shadowRoot","useOffsetPos","getBoundingClientRect","clientX","clientY","getCanvasPosition","round1","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","property","el","getPropertyValue","getStyle","getRtlAdapter","rtl","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","getSizeForArea","chartArea","field","Animator","_request","_charts","_running","_lastDate","_notify","anims","date","callbacks","numSteps","initial","currentStep","_refresh","_update","Date","now","remaining","running","items","draw","_active","_total","tick","pop","_getAnims","charts","complete","progress","listen","cb","acc","cur","_duration","stop","cancel","animator","interpolators","boolean","factor","c0","number","Animation","cfg","currentValue","_fn","_easing","_start","_loop","_target","_prop","_from","_to","_promises","elapsed","wait","res","rej","resolved","method","Animations","config","_chart","_properties","configure","animationOptions","animatedProps","option","_animateOptions","newOptions","$shared","$animations","resolveTargetOptions","_createAnimations","anim","awaitAll","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","applyStack","stack","dsIndex","singleMode","otherValue","found","isStacked","meta","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","controller","parsed","_cachedMeta","_stacks","iScale","iAxis","axis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","_visualValues","getFirstScaleId","shift","clearStacks","_parsed","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","static","_cachedDataOpts","getMeta","_type","_parsing","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","dataset","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","xScale","getScaleForId","yScale","rScale","getDatasetMeta","scaleID","_getOtherScale","reset","_destroy","_dataCheck","iAxisKey","vAxisKey","adata","convertObjectDataToArray","isExtensible","object","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","parse","sorted","_sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","range","parsedValue","NaN","getMinMax","canStack","otherScale","hidden","createStack","NEGATIVE_INFINITY","otherMin","otherMax","minDefined","maxDefined","getUserBounds","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","toClip","defaultClip","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","transition","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","binarySearch","metaset","spanGaps","lookupMethod","_reversePixels","distanceToDefinedLo","findIndex","distanceToDefinedHi","getRange","evaluateInteractionItems","position","handler","getSortedVisibleDatasetMetas","skip","getIntersectItems","useFinalPosition","isPointInArea","inRange","getNearestItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","center","getCenterPoint","getNearestCartesianItems","startAngle","endAngle","getProps","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","sort","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","params","layout","horizontal","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","other","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","changed","fullSize","setBoxDims","placeBoxes","userPadding","placed","stackWeight","layouts","addBox","_layers","z","removeBox","layoutItem","minPadding","availableWidth","availableHeight","layoutBoxes","isHorizontal","wrapBoxes","wrap","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","total","vBoxMaxWidth","hBoxMaxHeight","buildStacks","setLayoutDims","updatePos","change","handleMaxPadding","BasePlatform","acquireContext","aspectRatio","releaseContext","getMaximumSize","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","entries","trigger","entry","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","container","clientWidth","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","native","fromNativeEvent","addListener","DomPlatform","renderHeight","renderWidth","displayWidth","displayHeight","initCanvas","removeAttribute","proxies","$proxies","attach","detach","bbWidth","bbHeight","margins","maxHeight","containerSize","containerStyle","containerBorder","containerPadding","clientHeight","getContainerSize","isConnected","Element","tooltipPosition","hasValue","final","newTicks","spacing","majorStart","majorEnd","next","ceil","offsetFromEdge","edge","getTicksLimit","ticksLength","maxTicksLimit","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","_startPixel","_endPixel","lineValue","getPixelForTick","getTickMarkLength","getTitleHeight","titleAlign","reverseAlign","Scale","super","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_length","_maxLength","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","tickOpts","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","minmax","keepZero","_addGrace","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","determinedMaxTicks","_tickSize","maxScale","maxChart","determineMaxTicks","ticksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","first","skipMajors","evenMajorSpacing","diff","getEvenSpacing","factors","_factorize","calculateSpacing","avgMajorSpacing","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","startPixel","endPixel","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","jlen","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","gcLen","garbageCollect","valueAt","idx","getPixelForValue","getValueForPixel","getPixelForDecimal","decimal","getDecimalForPixel","getBasePixel","getBaseValue","createTickContext","optionTicks","rot","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","borderDash","borderDashOffset","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","getLineWidthForValue","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","titleX","titleY","titleArgs","tz","gz","bz","axisID","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","register","parentScope","isIChartComponent","itemDefaults","defaultRoutes","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","unregister","Registry","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","registry","component","camelMethod","PluginService","_init","notify","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","pluginScopeKeys","getIndexAxis","datasetDefaults","idMatchesAxis","axisFromPosition","determineAxis","scaleOptions","getAxisFromDataset","initOptions","chartDefaults","configScales","chartIndexAxis","scaleConf","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","mergeScaleConfig","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","Chart","invalidatePlugins","userConfig","initialCanvas","existingChart","OffscreenCanvas","_detectPlatform","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","debounce","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","newControllers","order","isDatasetVisible","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","getDatasetArea","getDatasetClipArea","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","pluginId","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","_isClickEvent","lastEvent","determineLastEvent","rThetaToXY","theta","pathArc","circular","pixelMargin","innerRadius","innerR","outerRadius","spacingOffset","avNogSpacingRadius","angleOffset","outerStart","outerEnd","innerStart","innerEnd","angleDelta","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","parseBorderRadius$1","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","generateLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","legendItem","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","adjustHitBoxes","rtlHelper","hitbox","_draw","defaultColor","halfFontSize","cursor","textDirection","fontColor","lineCap","lineJoin","lineDash","drawOptions","SQRT2","centerX","yBoxTop","xBoxLeft","drawLegendBox","_textX","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","previous","sameItem","plugin_legend","_element","_args","legend","afterEvent","ci","useBorderRadius","borderCapStyle","borderJoinStyle","WeakMap","positioners","average","xSet","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","createTooltipItem","formattedValue","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","beforeTitle","tooltipItems","labelCount","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","pt","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","centerY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","seasons","months","ROTATION_CONFIG","LABEL_STYLE_CONFIG","MONTH","FONT","COLOR","SEASON","rotatedLabelsPlugin","afterDatasetsDraw","multiLabels","_","datasetMeta","elementIndex","arcElement","labelConfiguration","styleConfig","createLabelConfiguration","configuration","middleAngle","middleRadius","labelPosition","calculateLabelPosition","rotationAngle","perpendicular","calculateTextRotationAngle","applyTextStyling","renderLabel","renderDatasetLabels","isString","defer","makeString","lastOfPathSeparatorRegExp","cleanKey","canNotTraverseDeeper","getLastOfPath","path","Empty","stackIndex","setPath","newValue","getPath","deepExtend","overwrite","regexEscape","_entityMap","chars","looksLikeObjectPathRegExpCache","capacity","regExpMap","regExpQueue","getRegExp","pattern","regExpFromCache","regExpNew","RegExp","deepFind","keySeparator","tokens","nextPath","getCleanedCode","code","consoleLogger","log","output","Logger","concreteLogger","logger","debug","forward","deprecate","lvl","debugOnly","moduleName","baseLogger","EventEmitter","observers","on","numListeners","off","emit","numTimesAdded","ResourceStore","defaultNS","ignoreJSONStructure","addNamespaces","removeNamespaces","getResource","lng","addResource","silent","addResources","resources","addResourceBundle","deep","skipCopy","pack","removeResourceBundle","hasResourceBundle","getResourceBundle","getDataByLanguage","hasLanguageSomeTranslations","find","toJSON","postProcessor","processors","addPostProcessor","handle","translator","processor","process","PATH_KEY","keysFromSelector","selector","state","revoke","revocable","createProxy","checkedLoadedFor","shouldHandleAsObject","Translator","services","changeLanguage","language","exists","interpolation","opt","returnObjects","extractFromKey","nsSeparator","namespaces","wouldCheckForNsInKey","seemsNaturalLanguage","userDefinedKeySeparator","userDefinedNsSeparator","possibleChars","matched","ki","substring","looksLikeObjectPath","interpolator","nestingRegexp","lastKey","overloadTranslationOptionHandler","returnDetails","namespace","appendNamespaceToCIMode","usedKey","exactUsedKey","usedLng","usedNS","usedParams","getUsedParamsDetails","resUsedKey","resExactUsedKey","joinArrays","handleAsObjectInI18nFormat","i18nFormat","handleAsObject","needsPluralHandling","hasDefaultValue","defaultValueSuffix","pluralResolver","getSuffix","defaultValueSuffixOrdinalFallback","ordinal","needsZeroSuffixLookup","pluralSeparator","resForObjHndl","resType","extendTranslation","usedDefault","isValidLookup","resForMissing","missingKeyNoValueFallbackToKey","updateMissing","fk","lngs","fallbackLngs","languageUtils","getFallbackCodes","fallbackLng","saveMissingTo","toResolveHierarchy","send","specificDefaultValue","defaultForMissing","missingKeyHandler","backendConnector","saveMissing","saveMissingPlurals","suffixes","getSuffixes","appendNamespaceToMissingKey","parseMissingKeyHandler","returnedObjectHandler","resTypeIsArray","copy","newKeyToUse","deepKey","defaultVariables","skipInterpolation","skipOnVariables","nestBef","nb","na","nest","postProcess","postProcessorNames","applyPostProcessor","postProcessPassResolved","i18nResolved","extracted","fallbackNS","needsContextHandling","codes","utils","hasLoadedNamespace","finalKeys","addLookupKeys","pluralSuffix","zeroSuffix","ordinalPrefix","contextKey","contextSeparator","possibleKey","returnNull","returnEmptyString","resourceStore","optionsKeys","useOptionsReplaceForData","LanguageUtil","supportedLngs","getScriptPartFromCode","formatLanguageCode","getLanguagePartFromCode","formattedCode","getCanonicalLocales","lowerCaseLng","cleanCode","isSupportedCode","load","nonExplicitSupportedLngs","getBestMatchFromCodes","cleanedLng","lngScOnly","lngOnly","supportedLng","fallbacks","default","fallbackCode","fallbackCodes","addCode","fc","suffixesOrder","zero","one","two","few","many","dummyRule","select","resolvedOptions","pluralCategories","PluralResolver","pluralRulesCache","getRule","cleanedCode","rule","PluralRules","err","lngPart","needsPlural","getPluralFormsOfKey","pluralCategory1","pluralCategory2","pluralCategory","prepend","deepFindWithDefaults","defaultData","getPathWithDefaults","regexSafe","Interpolator","escapeValue","escape","escape$1","useRawValueToEscape","prefixEscaped","suffixEscaped","formatSeparator","unescapeSuffix","unescapePrefix","nestingPrefix","nestingPrefixEscaped","nestingSuffix","nestingSuffixEscaped","nestingOptionsSeparator","maxReplaces","alwaysFormat","resetRegExp","getOrResetRegExp","existingRegExp","lastIndex","regexp","regexpUnescape","replaces","handleFormat","interpolationkey","trim","missingInterpolationHandler","regex","safeValue","todo","matchedVar","temp","clonedOptions","handleHasOptions","inheritedOptions","sep","optionsString","matchedSingleQuotes","matchedDoubleQuotes","keyEndIndex","lastIndexOf","elem","Boolean","createCachedFormatter","optForCache","formatParams","frm","createNonCachedFormatter","Formatter","cf","cacheInBuiltFormats","formats","currency","datetime","DateTimeFormat","relativetime","RelativeTimeFormat","ListFormat","addCached","mem","formatName","formatOptions","formatStr","optStr","rest","trimmedKey","parseFormatStr","formatted","valOptions","Connector","backend","store","waitingReads","maxParallelReads","readingCalls","maxRetries","retryTimeout","queue","queueLoad","languages","toLoad","pending","toLoadLanguages","toLoadNamespaces","hasAllNamespaces","reload","pendingCount","loaded","errors","q","pushPath","removePending","loadedKeys","fcName","tried","catch","prepareLoading","loadOne","fallbackValue","isUpdate","clb","initAsync","preload","simplifyPluralSuffix","partialBundledLanguages","tDescription","transformOptions","initImmediate","I18n","inst","isInitialized","isClone","isInitializing","defOpts","createClassOnDemand","ClassOrObject","lu","languageDetector","detection","deferred","finish","initializedStoreOnce","loadResources","usedCallback","append","resolvedLanguage","setResolvedLanguage","reloadResources","use","li","lngInLngs","unshift","isLanguageChangingTo","setLngProps","setLng","fl","cacheUserLanguage","async","detect","getFixedT","keyPrefix","fixedT","resultKey","setDefaultNamespace","lastLng","loadNotPending","loadState","precheck","preResult","loadNamespaces","loadLanguages","preloaded","newLngs","dir","Locale","getTextInfo","createInstance","instance","cloneInstance","forkResourceStore","mergedOptions","clonedData","mergedInterpolation","mergedForInterpolator","fieldContentRegExp","cookie","minutes","domain","cookieOptions","sameSite","expires","setTime","getTime","maxAge","TypeError","toUTCString","httpOnly","secure","partitioned","serializeCookie","nameEQ","ca","cookie$1","lookup","_ref","lookupCookie","_ref2","cookieMinutes","cookieDomain","querystring","lookupQuerystring","search","hash","lookupHash","lookupFromHashIndex","query","hasLocalStorageSupport","localStorageAvailable","localStorage","testKey","setItem","removeItem","lookupLocalStorage","getItem","hasSessionStorageSupport","sessionStorageAvailable","sessionStorage","lookupSessionStorage","navigator$1","navigator","userLanguage","htmlTag","internalHtmlTag","documentElement","lookupFromPathIndex","pathname","subdomain","lookupFromSubdomainIndex","internalLookupFromSubdomainIndex","hostname","canCookies","Browser","detectors","i18nOptions","excludeCacheFor","convertDetectedLanguage","lookupFromUrlIndex","addDetector","detector","detectionOrder","detected","detectorName","cacheName","_typeof","iterator","hasXMLHttpRequest","XMLHttpRequest","getOwnPropertySymbols","_objectSpread","_defineProperty","getOwnPropertyDescriptors","_toPrimitive","_toPropertyKey","XmlHttpRequestApi","ActiveXObjectApi","fetchApi","fetch","ActiveXObject","mod","addQueryString","queryString","paramName","fetchIt","fetchOptions","altFetch","response","statusText","status","altResponse","omitFetchOptions","payload","queryStringParams","headers","customHeaders","versions","version","arch","reqOptions","requestOptions","alternateFetch","requestWithFetch","open","crossDomain","setRequestHeader","withCredentials","overrideMimeType","onreadystatechange","readyState","responseText","requestWithXmlHttpRequest","_defineProperties","Backend","allOptions","_classCallCheck","_this","loadPath","addPath","parsePayload","parseLoadPayload","reloadInterval","credentials","timer","setInterval","unref","_readAny","loadUrlLanguages","loadUrlNamespaces","maybePromise","_this2","isPromise","resolvedLoadPath","loadUrl","_this3","errorMessage","term","parseErr","_this4","finished","dataArray","resArray","_this5","_this$services","currentLanguage","translatedLabelsPlugin","translateLabels","nextIndex","nextLanguage","i18n","translationKey","translatedTerm","translatedMultiLabels","animateRotate","animateScale","cutout","circumference","_getRotation","_getCircumference","_getRotationExtents","arcs","getMaxBorderWidth","getMaxOffset","maxSize","chartWeight","_getRingWeight","ratioX","ratioY","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","animationOpts","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","selfJoin","fullCircles","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","inner","angleMargin","clipArc","outerAngleClip","innerAngleClip","clipWidth","clipSelf","rootElement","canvasElement","seasonLabels","seasonValues","seasonColors","monthLabels","monthValues","monthColors","seriesLabels","initializeChart","rotationDegrees"],"ignoreList":[],"sourceRoot":""}